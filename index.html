<!DOCTYPE html>
<!-- changelog: rationale: Enable fullscreen toggle (F), keyboard shortcut, ARIA/data-node-id attributes, and reduced-motion fallbacks; source: presentation_inline.html lines 1-1740 -->
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhD Confirmation Presentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link rel="stylesheet" href="assets/roadmap.css">
    <script src="assets/roadmap.js" defer></script>

    <style>
        @import url('assets/vendor/google-fonts.css');


        * {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #F5F7FA;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px;
            overflow: hidden;
            size: 100vh;
        }

        .slide-wrapper {
            width: 1600px;
            height: 900px;
            position: relative;
        }

        .positioned-block {
            overflow: auto;
            padding: 8px;
        }

        .nav-container {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
        }

        /* Hide automatically-generated navigation dots; keep progress bar as primary navigation UI */
        #nav-dots {
            display: none !important;
        }

        .nav-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #E0E0E0;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-dot:hover {
            background: #0066CC;
        }

        .nav-dot.active {
            background: #0066CC;
            transform: scale(1.2);
        }

        .nav-arrows {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 24px;
            pointer-events: none;
        }

        .nav-arrow {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            pointer-events: all;
        }

        .nav-arrow:hover {
            background: #0066CC;
            color: white;
        }

        .nav-arrow.hidden {
            display: none;
        }

        .slide-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 102, 204, 0.1);
            transition: all 0.3s ease;
        }

        .slide-card:hover {
            box-shadow: 0 6px 30px rgba(0, 102, 204, 0.12);
        }

        .slide-title {
            font-size: 24px;
            font-weight: 700;
            color: #003366;
            margin-bottom: 16px;
        }

        /* Unified multi-tab toggle/button styles (applies to slide-level and subslide controls) */
        .slide-container {
            position: relative;
        }

        .toggle-group {
            display: flex;
            gap: 8px;
            align-items: center;
            position: absolute;
            top: 24px;
            right: 28px;
            z-index: 60;
        }

        /* multiple .toggle-controls may exist as children — make them inline and not positioned */
        .toggle-group .toggle-controls {
            position: static;
            display: inline-block;
            margin: 0;
            padding: 0;
        }

        .toggle-btn,
        .tab.toggle-btn,
        .subslide-btn {
            background: #fff;
            color: #111;
            border: 1px solid #ddd;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .toggle-btn i,
        .tab.toggle-btn i,
        .subslide-btn i {
            font-size: 14px;
            width: 16px;
            text-align: center;
            display: inline-block;
        }

        .toggle-btn[aria-pressed="true"],
        .toggle-btn[aria-selected="true"],
        .toggle-btn.active,
        .tab.toggle-btn[aria-selected="true"],
        .tab.toggle-btn.active,
        .subslide-btn[aria-selected="true"],
        .subslide-btn.active {
            background: #0066CC;
            color: #fff;
            border-color: #005bb5;
        }

        .toggle-btn:focus,
        .tab.toggle-btn:focus,
        .subslide-btn:focus {
            outline: 3px solid #0066CC;
            outline-offset: 2px;
        }

        /* Unified tab styling for multi-tab slides */
        .tablist {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tab {
            background: #fff;
            color: #111;
            border: 1px solid #ddd;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .tab i {
            font-size: 14px;
            width: 16px;
            text-align: center;
            display: inline-block;
        }

        .tab[aria-selected="true"],
        .tab.active {
            background: #0066CC;
            color: #fff;
            border-color: #005bb5;
        }

        .tab:hover {
            background: #f5f5f5;
        }

        .tab[aria-selected="true"]:hover,
        .tab.active:hover {
            background: #0052a3;
        }

        .tab:focus {
            outline: 3px solid #0066CC;
            outline-offset: 2px;
        }

        /* Centered tablist variant */
        .tablist.centered {
            justify-content: center;
            margin: 16px 0;
        }

        /* Right-aligned tablist variant (for top-right positioning with titles) */
        .tablist.right-aligned {
            justify-content: flex-end;
        }

        /* Tab panels container */
        .tabbed-pane {
            width: 100%;
        }

        .tab-panels {
            width: 100%;
        }

        .tab-panel {
            display: block;
        }

        .tab-panel[hidden],
        .tab-panel[aria-hidden="true"] {
            display: none;
        }

        /* Reduced-motion support for tabs */
        @media (prefers-reduced-motion: reduce) {
            .tab {
                transition: none;
            }

            .tablist {
                transition: none;
            }
        }

        /* Responsive: on narrow viewports, make controls flow inline below the title */
        @media (max-width: 900px) {
            .toggle-group {
                position: static;
                top: auto;
                right: auto;
                margin-top: 8px;
                flex-wrap: wrap;
                justify-content: flex-end;
            }

            .toggle-group .toggle-controls+.toggle-controls {
                margin-left: 6px;
            }

            .toggle-btn.full {
                width: 100%;
                box-sizing: border-box;
            }
        }

        /* Optional per-slide subtitle */
        .slide-subtitle {
            display: block;
            font-size: 18px;
            font-weight: 500;
            color: #0066CC;
            margin-top: 6px;
            margin-bottom: 12px;
            opacity: 0.95;
        }

        /* Edit-mode styles for draggable/resizable containers */
        body.edit-mode .editable {
            outline: 2px dashed rgba(0, 102, 204, 0.6);
            cursor: move;
        }

        body.edit-mode .editable.selected {
            outline: 3px solid rgba(0, 102, 204, 0.85);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
        }

        .edit-coords {
            position: absolute;
            right: 8px;
            top: 8px;
            z-index: 3500;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        body.edit-mode .edit-coords {
            display: block;
        }

        .resize-handle {
            position: absolute;
            right: 4px;
            bottom: 4px;
            width: 12px;
            height: 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 2px;
            z-index: 2000;
            cursor: se-resize;
            display: none;
        }

        body.edit-mode .resize-handle {
            display: block;
        }

        .edit-toolbar {
            position: fixed;
            top: 64px;
            right: 16px;
            z-index: 3000;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
            font-size: 13px;
            display: none;
        }

        body.edit-mode .edit-toolbar {
            display: block;
        }

        .ucl-header {
            background: linear-gradient(90deg, #0066CC 0%, #003366 100%);
            padding: 12px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ucl-logo {
            display: flex;
            align-items: center;
            gap: 12px;
            color: white;
            font-weight: 600;
            font-size: 18px;
        }

        .progress-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: rgba(0, 102, 204, 0.18);
            transition: height 160ms ease, background 160ms ease;
            z-index: 1001;
            cursor: pointer;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0066CC, #003366);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        /* Hover to enlarge progress bar for better visibility and interaction */
        .progress-container:hover {
            height: 12px;
            background: rgba(0, 102, 204, 0.25);
        }

        /* Speaker notes pane (collapsed by default). Visible only when NOT fullscreen. */
        #speaker-notes-container {
            /* anchor the pane just below the slide (top-based positioning) so it grows downward */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            /* position the top of the notes just beneath the slide inner (720px tall, centered) with a small gap */
            top: calc((100% + 720px) / 2);
            /* make the container slightly wider (less side margin) so the pane can be wider when collapsed */
            width: calc(100% + 32px);
            max-width: 1400px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1200;
            /* allow pointer events so the toggle button is interactable across the container */
            pointer-events: auto;
        }

        .speaker-notes {
            width: 1250px;
            max-width: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transition: max-height 260ms ease, opacity 200ms ease, transform 200ms ease;
            display: flex;
            align-items: center;
            box-sizing: border-box;
            pointer-events: auto;
        }

        .speaker-notes.collapsed {
            /* a bit taller so the button isn't cropped */
            max-height: 64px;
            min-height: 56px;
            opacity: 0.99;
            align-items: center;
            padding: 6px 12px;
        }

        .speaker-notes:not(.collapsed) {
            /* expand INTO the space below the slide (grow downward) and leave a small margin */
            max-height: calc((100% - 720px) / 2 - 12px);
            opacity: 1;
            /* ensure the pane's top stays fixed so height growth goes downward */
            transform-origin: top center;
        }

        #notes-toggle {
            background: linear-gradient(90deg, #003366, #0066CC);
            color: #fff;
            border: none;
            padding: 10px 14px;
            border-radius: 6px;
            margin: 8px 12px;
            cursor: pointer;
            align-self: center;
            pointer-events: auto;
        }

        #notes-content {
            padding: 14px 18px;
            font-size: 14px;
            color: #222;
            line-height: 1.4;
            overflow: auto;
            flex: 1 1 auto;
            max-height: 280px;
        }

        /* Ensure speaker notes never overflow the viewport.
           JS will compute exact positioning and max-height at runtime,
           but provide conservative CSS fallbacks for browsers without JS. */
        .speaker-notes {
            max-height: calc(100vh - 160px);
        }

        .speaker-notes.flipped {
            transform-origin: bottom center;
        }

        /* Hide notes in fullscreen mode to avoid overlap (also toggled by JS) */
        .slide-wrapper:fullscreen~#speaker-notes-container,
        .slide-wrapper:-webkit-full-screen~#speaker-notes-container,
        body.fullscreen-lock #speaker-notes-container {
            display: none !important;
        }

        /* Make sure progress is visible in fullscreen and interactive */
        .slide-wrapper:fullscreen .progress-container,
        .slide-wrapper:-webkit-full-screen .progress-container {
            height: 12px !important;
            /* moved down for fullscreen */
            background: rgba(0, 102, 204, 0.22) !important;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .expandable-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0, 102, 204, 0.1);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .expandable-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: #0066CC;
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }

        .expandable-card:hover::before {
            transform: scaleY(1);
        }

        .expandable-card:hover {
            transform: translateX(8px);
            box-shadow: 0 8px 25px rgba(0, 102, 204, 0.15);
            border-color: #0066CC;
        }

        .expandable-card:active {
            transform: translateX(12px) scale(0.98);
        }

        .roadmap-container {
            display: flex;
            gap: 32px;
            padding: 24px;
        }

        .roadmap-lane {
            flex: 1;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        .roadmap-lane:hover {
            box-shadow: 0 6px 30px rgba(0, 102, 204, 0.12);
        }

        /* Interactive roadmap now uses existing containers in the slide;
              buttons removed to rely on collapsible/expandable elements. */
        .kpi-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: linear-gradient(90deg, #0066CC, #003366);
            color: white;
            border-radius: 24px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: default;
        }

        .kpi-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 102, 204, 0.4);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
        }

        /* Header right section (section titles placed in the top-right of the header) */
        .ucl-header .header-section-title {
            color: #ffffff;
            font-size: 14px;
            font-weight: 600;
            margin-left: 12px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .status-badge.published {
            background: #E6F7E6;
            color: #228B22;
        }

        .status-badge.submitted {
            background: #FFF3E6;
            color: #E67E22;
        }

        /* accepted shares the same visual treatment as published (same bg + color),
           slides should use different icon markup to distinguish semantically */
        .status-badge.accepted {
            background: #E6F7E6;
            color: #228B22;
        }

        /* Enhanced Interactive Elements */
        .expandable-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(0, 102, 204, 0.1);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .expandable-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: #0066CC;
            transform: scaleY(0);
            transition: transform 0.3s ease;
        }

        .expandable-card:hover::before {
            transform: scaleY(1);
        }

        .expandable-card:hover {
            transform: translateX(8px);
            box-shadow: 0 8px 25px rgba(0, 102, 204, 0.15);
            border-color: #0066CC;
        }

        .expandable-card:active {
            transform: translateX(12px) scale(0.98);
        }

        /* Roadmap item enhancements */
        /* rationale: apply realistic multi-layer shadow to milestone components */
        /* source: presentation.html (roadmap item block) */
        .roadmap-item {
            padding: 12px 16px;
            margin-bottom: 8px;
            background: #F8FAFC;
            border-radius: 8px;
            border-left: 3px solid #0066CC;
            font-size: 16px;
            color: #333;
            transition: all 0.25s ease;
            cursor: default;
            /* Realistic multi-layer shadow */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.18),
                /* contact shadow */
                0 8px 20px rgba(0, 0, 0, 0.12),
                /* mid-range soft shadow */
                0 16px 32px rgba(0, 0, 0, 0.08);
            /* far penumbra */
        }

        .roadmap-item:hover {
            background: linear-gradient(90deg, rgba(0, 102, 204, 0.08), transparent);
            padding-left: 20px;
            border-left-width: 5px;
            /* Slightly stronger layered shadow on hover */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.22),
                0 12px 28px rgba(0, 0, 0, 0.14),
                0 24px 48px rgba(0, 0, 0, 0.10);
        }

        /* Slide card hover */
        .slide-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 102, 204, 0.1);
            transition: all 0.3s ease;
        }

        .slide-card:hover {
            box-shadow: 0 6px 30px rgba(0, 102, 204, 0.12);
        }

        /* KPI badge hover */
        .kpi-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: linear-gradient(90deg, #0066CC, #003366);
            color: white;
            border-radius: 24px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: default;
        }

        .kpi-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 102, 204, 0.4);
        }

        /* Progress bar animation */
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0066CC, #003366);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        /* Navigation enhancements */
        .nav-arrow {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: all;
        }

        .nav-arrow:hover {
            background: #0066CC;
            color: white;
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 102, 204, 0.3);
        }

        .nav-arrow:active {
            transform: scale(0.95);
        }

        .nav-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #E0E0E0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .nav-dot:hover {
            background: #0066CC;
            transform: scale(1.3);
        }

        .nav-dot.active {
            background: #0066CC;
            transform: scale(1.2);
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.2);
        }

        /* Keyboard hint */
        .keyboard-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 51, 102, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            z-index: 1000;
        }

        .keyboard-hint.visible {
            opacity: 1;
        }

        .keyboard-hint kbd {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 4px;
            font-family: 'Inter', sans-serif;
        }

        /* Slide transition */
        .slide-container {
            width: 1280px;
            height: 720px;
            margin: 0 auto;
            background: linear-gradient(180deg, #F0F8FF 0%, #E6F3FF 100%);
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
            animation: slideIn 0.4s ease-out;
        }

        /* Roadmap slides (morph-like transition without zoom animation) */
        .slide-container:has(.stage) {
            animation: none;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Focus states for accessibility */
        .nav-arrow:focus,
        .nav-dot:focus,
        .expandable-card:focus {
            outline: 3px solid rgba(0, 102, 204, 0.5);
            outline-offset: 2px;
        }

        /* Title animation on first slide */
        .title-animate {
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Subtle pulse for important elements */
        .pulse-subtle {
            animation: pulseShadow 2s ease-in-out infinite;
        }

        @keyframes pulseShadow {

            0%,
            100% {
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            }

            50% {
                box-shadow: 0 4px 25px rgba(0, 102, 204, 0.15);
            }
        }

        /* Fullscreen support: make slide-wrapper fill the viewport when fullscreen */
        .slide-wrapper:fullscreen,
        .slide-wrapper:-webkit-full-screen {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            border-radius: 0 !important;
        }

        /* Ensure the inner slide content fills the fullscreen viewport (override fixed sizes)
           and prohibit internal scrolling so slides cannot overflow the viewport. */
        .slide-wrapper:fullscreen .slide-container,
        .slide-wrapper:-webkit-full-screen .slide-container {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            margin: 0 !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            overflow: hidden !important;
            box-sizing: border-box !important;
        }

        /* When fullscreen, center the slides container so scaled slides sit centrally */
        .slide-wrapper:fullscreen #slides-container,
        .slide-wrapper:-webkit-full-screen #slides-container {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            width: 100%;
            height: 100%;
        }

        /* Default slide container baseline for positioned overlays */
        .slide-container {
            position: relative;
        }

        /* Default inner wrapper for slide content (used for fullscreen scaling) */
        .slide-inner {
            width: 1280px;
            height: 720px;
            display: block;
        }

        /* Slide number badge: anchor to the viewport (fixed) so it does not shift
           when slides scale/transform. Kept small and non-interactive. */
        .slide-counter {
            position: fixed;
            bottom: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 11px;
            line-height: 1;
            z-index: 10050;
            pointer-events: none;
            opacity: 0.95;
            box-sizing: border-box;
            max-width: calc(100% - 32px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .slide-wrapper:fullscreen .slide-counter,
        .slide-wrapper:-webkit-full-screen .slide-counter {
            position: fixed;
            bottom: 12px;
            right: 12px;
            font-size: 12px;
            opacity: 0.95;
            z-index: 10005;
            box-sizing: border-box;
            max-width: calc(100% - 32px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 6px 8px;
            /* anchor to viewport when fullscreen so the counter sits in the bottom-right corner of the screen
               (otherwise it is positioned inside the scaled slide box and appears offset); also constrain the
               counter size and truncate long content to avoid overflow when slides or viewports scale */
        }

        /* Progress hover preview */
        .progress-preview {
            position: fixed;
            display: none;
            width: 320px;
            height: 180px;
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
            z-index: 2200;
            pointer-events: none;
            transform: translate(-50%, -110%);
        }

        .progress-preview .thumb {
            transform-origin: top left;
            pointer-events: none;
            display: block;
        }

        /* Progress bar hover zones (visual separators per slide) */
        .progress-zones {
            position: absolute;
            inset: 0;
            display: none;
            pointer-events: none;
        }

        .progress-zones .zone {
            position: absolute;
            top: 0;
            bottom: 0;
            border-right: 1px solid rgba(255, 255, 255, 0.18);
            box-sizing: border-box;
            pointer-events: none;
        }

        .progress-zones .zone.active {
            background: rgba(0, 102, 204, 0.06);
        }

        .progress-container:hover .progress-zones {
            display: block;
        }

        /* Fullscreen toggle button */
        #fullscreen-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 1002;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            border: none;
        }

        #fullscreen-toggle:focus {
            outline: 3px solid rgba(0, 102, 204, 0.45);
        }

        /* Reduced motion preference: disable transitions/animations */
        @media (prefers-reduced-motion: reduce) {
            * {
                transition: none !important;
                animation: none !important;
            }

            .progress-bar::after {
                animation: none !important;
            }
        }

        /* Hide speaker notes from slide view (visible only in presenter mode) */
        .notes,
        aside.notes {
            display: none !important;
        }
    </style>
    <link rel="stylesheet" href="assets/papers.css">
    <script src="assets/papers.js" defer></script>

<!-- Injected slide styles -->
<style>
/* Pillar Card Styling - 1x3 + 1x1 Layout */
    /* Pill icons */
    .pill-icon {
        font-size: 14px;
        display: inline-block;
        width: 14px;
        height: 14px;
        margin-right: 8px;
        vertical-align: middle;
    }

    .key-takeaway {
        font-weight: 700;
    }

    .pillar-pubs {
        margin-top: 8px;
        font-size: 12px;
        color: #666;
        font-style: italic;
    }

    .pub-icon {
        margin-right: 6px;
        color: #666;
        font-size: 12px;
        vertical-align: middle;
    }

    .pub-status {
        margin-left: 6px;
        font-size: 12px;
        vertical-align: middle;
    }

    .pub-status.accepted {
        color: #2e7d32;
    }

    .pub-status.pending {
        color: #f9a825;
    }

    /* publication entry structure */
    .pub-entry {
        display: inline-flex;
        align-items: center;
        gap: 6px;
    }

    .pub-text {
        margin-left: 4px;
        color: #444;
    }

    .pub-badges {
        margin-left: 6px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
    }

    .pub-folder {
        font-size: 11px;
        color: #888;
    }

    /* two-column layout for horizontal pillar content */
    .pillar-horizontal-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        column-gap: 18px;
        row-gap: 8px;
        align-items: start;
    }

    @media (max-width: 900px) {
        .pillar-horizontal-grid {
            grid-template-columns: 1fr;
        }

        .pillar-card-body-horizontal {
            padding: 12px;
        }
    }

    .pillar-card[data-pillar="1"] .pill-icon {
        color: #1565C0;
    }

    .pillar-card[data-pillar="1"] .pillar-card-body {
        color: #1565C0;
    }

    .pillar-card[data-pillar="2"] .pill-icon {
        color: #3949AB;
    }

    .pillar-card[data-pillar="2"] .pillar-card-body {
        color: #3949AB;
    }

    .pillar-card[data-pillar="3"] .pill-icon {
        color: #5E35B1;
    }

    .pillar-card[data-pillar="3"] .pillar-card-body {
        color: #5E35B1;
    }

    .pillar-card[data-pillar="4"] .pill-icon {
        color: #7B1FA2;
    }

    .pillar-card[data-pillar="4"] .pillar-card-body-horizontal {
        color: #7B1FA2;
    }

    .pillars-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
    }

    .pillars-row-1 {
        display: grid;
        grid-template-columns: 0.9fr 0.9fr 1.2fr;
        gap: 8px;
        align-items: center;
        /* center vertically within the slide container */
        margin-top: auto;
        margin-bottom: auto;
    }

    .pillars-row-2 {
        display: flex;
        justify-content: center;
    }

    .pillar-card {
        border-radius: 8px;
        overflow: hidden;
        background: white;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: all 300ms ease;
        display: flex;
        flex-direction: column;
    }

    .pillar-card:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        transform: translateY(-2px);
    }

    .pillar-card-header {
        flex-shrink: 0;
    }

    .pillar-card-body {
        flex: 1;
    }

    .pillar-card-horizontal {
        border-radius: 8px;
        overflow: hidden;
        background: white;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        transition: all 300ms ease;
    }

    .pillar-card-horizontal:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        transform: translateY(-2px);
    }

    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce) {
        .pillar-card {
            transition: none !important;
        }

        .pillar-card:hover {
            transform: none !important;
        }

        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }
    }

    /* Responsive: stack vertically on smaller screens */
    @media (max-width: 1200px) {
        .pillars-row-1 {
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .pillar-card-horizontal {
            max-width: 100% !important;
        }

        .pillar-card-horizontal>div:first-child {
            flex-direction: row;
            min-width: auto;
            padding: 16px;
        }
    }

    @media (max-width: 768px) {
        .pillar-card-horizontal>div:first-child {
            flex-direction: column;
            border-right: none;
            border-bottom: 3px solid #6A1B9A;
        }

        .pillar-card-horizontal .pillar-card-header-horizontal {
            min-width: auto;
        }
    }
@media (prefers-reduced-motion: reduce) {
        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }
    }

    .expandable-card:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    .expandable-card.active {
        background: #f0f8ff;
        border: 2px solid #0066CC;
    }

    /* Tabbed panes */
    .tablist.centered {
        margin: 12px 0;
    }

    .panel-caption {
        font-size: 12px;
        color: #333;
        margin-top: 8px;
    }

    .sr-only {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }

    /* Card grid and accessible details */
    .card-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
    }

    .card {
        background: #fff;
        border: 1px solid #EDF6FF;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.03);
    }

    .card summary {
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        font-weight: 600;
        list-style: none;
    }

    .card summary:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
        border-radius: 6px;
    }

    .card .icon {
        width: 28px;
        height: 28px;
        color: #0066CC;
        font-size: 18px;
    }

    .card .card-content {
        margin-top: 8px;
        color: #333;
        font-size: 14px;
    }

    /* Pipeline representation — icon steps, no inner boxes */
    .pipeline-graphic {
        display: flex;
        align-items: center;
        gap: 14px;
        padding: 6px 0;
        background: transparent;
        border-radius: 0;
        margin-bottom: 12px;
    }

    .pipeline-step {
        text-align: center;
        flex: 1;
    }

    .icon-circle {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: #f0f8ff;
        color: #0066CC;
        font-size: 18px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        margin: 0 auto;
    }

    .pipeline-arrow {
        color: #0066CC;
        font-size: 36px;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 36px;
    }

    @media (max-width: 720px) {
        .pipeline-arrow {
            font-size: 22px;
            min-width: 28px;
        }
    }

    .step-label {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-weight: 700;
        margin-top: 8px;
    }

    .step-keywords {
        font-size: 12px;
        color: #666;
        margin-top: 4px;
    }

    /* Badges and keywords */
    .badges {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: flex-start;
    }

    .badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 999px;
        font-weight: 700;
        background: #f7f7f7;
        color: #333;
    }

    .badge.positive {
        background: linear-gradient(90deg, #E8F5E9, #C8E6C9);
        color: #2E7D32;
        border-left: 4px solid #4CAF50;
    }

    .badge.info {
        background: #FFF8E1;
        color: #5D4037;
        border-left: 4px solid #FFC107;
    }

    /* Takeaway box for quick highlights */
    .takeaway {
        background: linear-gradient(90deg, #E8F5FF, #F7FBFF);
        border-left: 4px solid #0066CC;
        padding: 10px 12px;
        border-radius: 6px;
        color: #003a66;
        font-weight: 700;
        font-size: 14px;
    }

    .highlight {
        color: #0066CC;
        font-weight: 700;
    }

    .keywords {
        margin-top: 8px;
        padding-left: 0;
        list-style: none;
        display: grid;
        gap: 8px;
    }

    .keywords li {
        display: flex;
        gap: 8px;
        align-items: center;
        font-size: 13px;
        color: #333;
    }

    /* Header project badge */
    .project-badge {
        font-size: 11px;
        background: #e9f3ff;
        color: #004899;
        padding: 4px 8px;
        border-radius: 6px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
    }

    .keyword {
        background: #f0f8ff;
        color: #004899;
        padding: 4px 8px;
        border-radius: 999px;
        font-weight: 700;
        display: inline-flex;
        gap: 6px;
        align-items: center;
        font-size: 12px;
    }

    /* Centered tab bar polish */
    .tablist.centered {
        justify-content: center;
    }

    .tablist.centered .tab {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid #e6eefb;
        background: #fff;
    }

    .tablist.centered .tab[aria-selected="true"],
    .tablist.centered .tab.active {
        background: #0066CC;
        color: #fff;
    }

    .tablist.centered .tab:hover,
    .tablist.centered .tab:focus {
        transform: translateY(-1px);
        box-shadow: 0 6px 18px rgba(2, 70, 155, 0.06);
    }

    .balanced-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 24px;
        align-items: start;
        min-height: 220px;
    }

    .slide3-intro-image {
        width: 100%;
        height: auto;
        /* allow a larger, responsive preview while preserving aspect ratio */
        max-width: 560px;
        max-height: 560px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        display: block;
        object-fit: contain;
    }

    .balanced-grid aside {
        background: transparent;
    }

    @media (prefers-reduced-motion: reduce) {

        .panel-anim-enter-right,
        .panel-anim-exit-left,
        .panel-anim-enter-left,
        .panel-anim-exit-right {
            animation: none !important;
        }
    }

    /* Generation gallery styles (ControlNet tab) */
    .generation-gallery .generation-main img {
        transition: opacity 200ms ease;
        display: block;
    }

    .generation-thumb img {
        transition: transform 150ms ease;
    }

    .generation-thumb[aria-pressed="true"] img {
        outline: 2px solid #0066CC;
        transform: scale(1.02);
    }

    .generation-prev,
    .generation-next {
        color: #0066CC;
        background: transparent;
        border: none;
        font-size: 20px;
        padding: 8px;
        cursor: pointer;
    }

    .generation-prev:focus,
    .generation-next:focus,
    .generation-thumb:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    @media (prefers-reduced-motion: reduce) {

        .generation-gallery .generation-main img,
        .generation-thumb img {
            transition: none !important;
            transform: none !important;
        }
    }

    /* ControlNet flow — full-width three-step layout */
    .controlnet-flow {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 18px;
        align-items: start;
        margin-top: 6px;
    }

    .controlnet-step {
        text-align: center;
    }

    .controlnet-step .step-image img {
        max-width: 360px;
        width: 100%;
        height: auto;
        display: block;
        margin: 0 auto;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    }

    /* Grid used by ControlNet panel (gallery embedded in Generation step) */
    .controlnet-pipeline-grid {
        display: grid;
        grid-template-columns: 1fr 0.06fr 1fr 0.06fr 1fr;
        gap: 8px;
        /* reduced horizontal gap */
        align-items: center;
    }

    @media (max-width: 720px) {
        .controlnet-pipeline-grid {
            grid-template-columns: 1fr;
        }

        .controlnet-pipeline-grid .pipeline-arrow {
            display: none;
            /* hide arrows on very small widths to save space */
        }
    }

    /* Generation gallery: main image + vertical thumbnail column */
    .generation-gallery .generation-main {
        display: flex;
        align-items: center;
        gap: 8px;
        /* slightly tighter */
    }

    .generation-gallery .generation-thumbs {
        display: flex;
        flex-direction: column;
        gap: 8px;
        justify-content: center;
        margin-left: 8px;
    }

    @media (max-width: 720px) {
        .generation-gallery {
            display: block;
            text-align: center;
        }

        .generation-gallery .generation-main {
            flex-direction: column;
        }

        .generation-gallery .generation-thumbs {
            flex-direction: row;
            justify-content: center;
            margin-left: 0;
            margin-top: 8px;
        }
    }

    /* Ensure consistent sizes & vertical alignment for ControlNet pipeline images */
    #slide3-panel-controlnet .pipeline-step {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        /* center content vertically so images align across columns */
        min-height: 220px;
    }

    /* Allow the image to use the full area in the ControlNet pipeline steps
       (override the small circular icon used elsewhere) */
    #slide3-panel-controlnet .pipeline-step .icon-circle {
        width: auto;
        height: auto;
        padding: 0;
        border-radius: 6px;
        background: #f0f8ff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        overflow: visible;
    }

    /* Use contain so the whole image is visible and add max-width for responsiveness */
    #slide3-panel-controlnet .pipeline-step .icon-circle img,
    #slide3-panel-controlnet .generation-main img {
        width: 160px;
        height: 160px;
        object-fit: contain;
        max-width: 100%;
        display: block;
        border-radius: 6px;
    }

    #slide3-panel-controlnet .step-label {
        margin-top: 10px;
    }

    /* Make generation gallery slightly smaller than other images */
    .generation-main img {
        max-width: 360px;
        max-height: 240px;
    }

    .generation-thumbs img {
        width: 64px;
        height: 48px;
    }

    @media (max-width: 720px) {
        .controlnet-flow {
            grid-template-columns: 1fr;
        }

        .generation-main img {
            max-width: 320px;
        }
    }

    < !-- changelog: rationale: scope svg rule to slide to avoid global override;
    source: slides/03.html#L912-L920 -->

    /* Fix: ensure SVG assets scale to container and do not get cropped
       Scoped to this slide only so it does not overwrite global CSS rules. */
    .slide-container[data-node-id="roadmap-node-cia"] img[src$=".svg"] {
        width: 100%;
        height: auto;
        max-width: 100%;
        object-fit: contain;
    }
@media (prefers-reduced-motion: reduce) {
        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }
    }

    .card {
        background: #fff;
        border: 1px solid #EDF6FF;
        border-radius: 8px;
        padding: 12px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.03);
    }

    .card h4 {
        font-size: 14px;
    }

    .bayesian-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 102, 204, 0.12);
        border-color: #0066CC;
    }

    .bayesian-card:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    .balanced-grid {
        display: grid;
        grid-template-columns: 1fr 420px;
        gap: 16px;
        align-items: start;
    }

    .balanced-grid aside {
        background: transparent;
    }

    .panel-caption {
        font-size: 12px;
        color: #333;
        margin-top: 8px;
    }

    /* UQ panel layout: centered single-column with image on top */
    .uq-grid {
        display: flex;
        flex-direction: column;
        gap: 0;
        align-items: center;
        justify-items: center;
        max-width: 680px;
        margin: 0 auto;
    }

    .uq-visual {
        text-align: center;
        width: 100%;
    }

    .uq-text {
        text-align: center;
        width: 100%;
    }

    .uq-visual img {
        width: 100%;
        height: auto;
        max-width: 100%;
        min-height: 240px;
        border-radius: 8px;
        display: block;
        box-sizing: border-box;
    }

    .uq-heading {
        font-weight: 700;
        color: #0066CC !important;
        font-size: 26px;
        margin-top: 0;
        margin-bottom: 14px;
        line-height: 1.3;
    }

    .uq-lead {
        font-size: 17px;
        color: #333;
        margin: 0 0 18px 0;
        line-height: 1.55;
        font-weight: 500;
    }

    .uq-context {
        padding: 16px;
        background: rgba(0, 102, 204, 0.06);
        border-radius: 8px;
        border-left: 4px solid #0066CC;
        margin-bottom: 16px;
        text-align: left;
    }

    .uq-context p {
        font-size: 15px;
        color: #333;
        margin: 0 0 12px 0;
        line-height: 1.5;
    }

    .uq-context p:last-child {
        margin-bottom: 0;
    }

    .uq-definition {
        padding: 14px 16px;
        background: linear-gradient(135deg, rgba(0, 102, 204, 0.08), rgba(0, 102, 204, 0.04));
        border-radius: 8px;
        border: 1px solid rgba(0, 102, 204, 0.12);
        margin-bottom: 14px;
    }

    .uq-goal {
        padding: 16px;
        background: rgba(0, 102, 204, 0.08);
        border-radius: 8px;
        border-left: 4px solid #0066CC;
        color: #333;
        font-size: 16px;
        font-weight: 500;
        margin-bottom: 12px;
        line-height: 1.5;
    }

    #slide4-dice-caption {
        font-size: 12px;
        color: #d8eaf8 !important;
        margin-top: 10px;
        text-align: left;
    }

    @media (max-width: 760px) {
        .uq-grid {
            grid-template-columns: 1fr;
        }

        .uq-visual {
            margin-bottom: 12px;
        }

        .uq-heading {
            font-size: 17px;
        }
    }

    .sr-only {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
    }

    .tablist {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }

    .tab {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 12px;
        border-radius: 10px;
        border: 1px solid #e6eefb;
        background: #fff;
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
        color: #333;
        transition: all 0.2s ease;
    }

    .tab:hover,
    .tab:focus {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 102, 204, 0.1);
        border-color: #0066CC;
    }

    .tab[aria-selected="true"],
    .tab.active {
        background: #0066CC;
        color: #fff;
        border-color: #0066CC;
    }

    .tab-panel {
        display: block;
    }

    .tab-panel[aria-hidden="true"],
    .tab-panel[hidden] {
        display: none;
    }

    .progress-container {
        position: absolute;
        bottom: 0;
    }

    /* changelog: rationale: Ensure diagrams/equation images remain readable on light backgrounds by
                        providing a white fill and subtle discrete shadows. source: slides/04.html (this style block) */
    /* Ensure diagrams, embedded SVGs and equation images are readable without a dark backdrop */
    .uq-visual img,
    .methods-visual img,
    #svg-container img,
    section[data-node-id="roadmap-node-uq-sota"] img[role="img"],
    figure img {
        background-color: #ffffff;
        border-radius: 8px;
        box-shadow: 0 10px 24px rgba(16, 40, 80, 0.09), 0 2px 6px rgba(16, 40, 80, 0.04);
        -webkit-filter: drop-shadow(0 6px 18px rgba(16, 40, 80, 0.07));
        filter: drop-shadow(0 6px 18px rgba(16, 40, 80, 0.07));
        background-clip: padding-box;
        overflow: visible !important;
        max-width: 100% !important;
        min-width: 0;
    }

    /* If SVGs are inlined instead of img tags, target them too */
    .methods-visual svg,
    .uq-visual svg,
    figure svg {
        background-color: #ffffff;
        border-radius: 8px;
        box-shadow: 0 10px 24px rgba(16, 40, 80, 0.09), 0 2px 6px rgba(16, 40, 80, 0.04);
        filter: drop-shadow(0 6px 18px rgba(16, 40, 80, 0.07));
        max-width: 100%;
        height: auto;
        min-height: 380px;
        display: block;
        padding: 12px;
        margin: 0;
        overflow: visible !important;
        width: 100%;
        box-sizing: border-box;
    }

    /* Ensure SVG text elements have high contrast and are readable */
    .methods-visual svg text,
    .methods-visual svg tspan,
    .uq-visual svg text,
    .uq-visual svg tspan,
    figure svg text,
    figure svg tspan {
        fill: #1a1a1a !important;
        stroke: none !important;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", sans-serif !important;
    }

    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #0066CC, #00d4ff);
        transition: width 0.3s ease;
    }

    .slide-counter {
        position: absolute;
        bottom: 12px;
        right: 16px;
        font-size: 12px;
        color: #999;
        font-weight: 600;
    }

    /* Methods layout: responsive design for buttons + SVG */
    .methods-layout {
        display: grid;
        grid-template-columns: 1fr 2fr;
        gap: 16px;
        margin-bottom: 16px;
    }

    .methods-buttons-container {
        margin: 24px;
        display: flex;
        flex-direction: row;
        gap: 12px;
        flex-wrap: wrap;
        align-items: stretch;
    }

    .methods-visual {
        text-align: center;
        width: 100%;
        overflow: visible;
    }

    /* Desktop layout: buttons on left (vertical), SVG on right */
    @media (min-width: 920px) {
        .methods-layout {
            flex-direction: row;
            gap: 18px;
            align-items: flex-start;
        }

        .methods-buttons-container {
            flex-direction: column;
            flex: 0 0 auto;
            min-width: 170px;
        }

        .methods-visual {
            flex: 1;
        }
    }

    /* Method buttons: responsive grid and improved visuals */
    .method-grid {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
    }

    .method-button {
        background: none;
        border: none;
        padding: 0;
        cursor: pointer;
        transition: transform 0.22s cubic-bezier(.2, .9, .2, 1), box-shadow 0.22s;
        border-radius: 8px;
        overflow: visible;
        text-align: left;
        flex: 1;
        min-width: 140px;
    }

    @media (min-width: 920px) {
        .method-button {
            flex: 1 1 100%;
            min-width: auto;
        }
    }

    .method-button:hover {
        transform: translateY(-4px);
        box-shadow: 0 12px 28px rgba(0, 102, 204, 0.12);
    }

    .method-button:focus {
        outline: none;
    }

    .method-button:focus-visible {
        box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.12);
    }

    /* Pressed / active state (syncs with aria-pressed) */
    .method-button[aria-pressed="true"],
    .method-button.active {
        transform: none;
    }

    .method-button[aria-pressed="true"] .card,
    .method-button.active .card {
        background: linear-gradient(135deg, #e8f4ff 0%, #fff3e6 100%);
        border: 2px solid #0066CC;
        box-shadow: 0 6px 20px rgba(0, 102, 204, 0.18);
        transform: scale(1.01);
    }

    .method-button .card {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 14px;
        background: #fff;
        border-radius: 8px;
        border: 1px solid rgba(0, 0, 0, 0.06);
        transition: all 0.18s ease;
        min-height: 86px;
    }

    .method-button .card h4 {
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 0;
    }

    .method-button .card h4 i {
        font-size: 18px;
        color: #0066CC;
        width: 22px;
        text-align: center;
    }

    .method-title {
        font-weight: 700;
        color: #0066CC;
    }

    .method-desc {
        font-size: 13px;
        color: #333;
        margin: 0;
    }

    @media (min-width: 980px) {
        .method-button .card {
            padding: 16px;
        }
    }

    /* Slide-specific: neutral light background for better text readability */
    section[data-node-id="roadmap-node-uq-sota"] {
        background: #f5f8fb;
        color: #333;
    }

    section[data-node-id="roadmap-node-uq-sota"] .slide-title,
    section[data-node-id="roadmap-node-uq-sota"] .slide-subtitle {
        color: #0066CC !important;
    }

    section[data-node-id="roadmap-node-uq-sota"] .status-banner {
        color: #333 !important;
    }

    section[data-node-id="roadmap-node-uq-sota"] .slide-counter {
        color: #999 !important;
    }

    section[data-node-id="roadmap-node-uq-sota"] #svg-caption,
    section[data-node-id="roadmap-node-uq-sota"] #slide4-dice-caption {
        color: #333 !important;
        background: transparent !important;
    }

    section[data-node-id="roadmap-node-uq-sota"] #svg-container,
    section[data-node-id="roadmap-node-uq-sota"] #dice-container {
        box-shadow: 0 8px 24px rgba(0, 60, 110, 0.15);
    }
.tab-panel img {
        max-width: 100%;
        width: 100%;
        height: auto !important;
        display: block;
        margin: 0 auto;
        border-radius: 8px;
        object-fit: contain;
    }

    /* Fallback grid styling in case JS hasn't injected global styles yet */
    .methods-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
    }

    @media (max-width: 720px) {
        .methods-grid {
            grid-template-columns: 1fr;
        }
    }

    .method-visual[data-zoomable="true"] {
        cursor: zoom-in;
    }

    .zoom-hint {
        font-size: 10px;
        color: #666;
        margin-top: 6px;
    }

    /* Crop bottom of images: responsive height and safe overflow */
    .crop-bottom {
        overflow: hidden;
        height: 320px;
        /* default crop height */
        border-radius: 8px;
    }

    .crop-bottom img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        object-position: top center;
        display: block;
    }

    /* Slide 5 contrast improvements: add opaque panels behind images/text for legibility */
    #slide5-panel-intro .method-visual,
    #slide5-panel-intro .fragment,
    #slide5-panel-methods .metric-gallery,
    #slide5-panel-methods .fragment,
    #slide5-panel-results .fragment {
        background: rgba(255, 255, 255, 0.96);
        padding: 14px;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        color: #111 !important;
    }

    /* Ensure main image area has opaque backdrop and clear padding */
    #slide5-panel-intro .method-visual img,
    #slide5-panel-methods .metric-main,
    #slide5-panel-results img {
        background: rgba(255, 255, 255, 1);
        padding: 10px;
        border-radius: 8px;
        box-shadow: none;
    }

    /* Increase caption contrast */
    #slide5-panel-intro .panel-caption,
    #slide5-panel-methods .panel-caption,
    #slide5-panel-results .panel-caption {
        color: #222;
        font-weight: 600;
    }

    @media (max-width: 720px) {
        .crop-bottom {
            height: 220px;
        }
    }

    /* ABDO double-image container */
    .datasets-abdo-container {
        display: flex;
        gap: 12px;
        justify-content: center;
        align-items: center;
    }

    .datasets-abdo-container img {
        max-width: 100%;
        object-fit: contain;
        display: block;
        margin: 0 auto;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Ensure ABDO double images evenly fill the gallery container height */
    .datasets-abdo-img {
        width: 49%;
        height: 100%;
        object-fit: contain;
        display: block;
        margin: 0;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    @media (max-width: 720px) {
        .datasets-abdo-container {
            flex-direction: column;
        }

        .datasets-abdo-container img {
            width: 100%;
            max-height: 220px;
        }

        .datasets-abdo-img {
            width: 100%;
            height: auto;
            max-height: 220px;
        }
    }

    /* ABDO double-image container */
    /* Datasets gallery styles */
    .datasets-gallery .datasets-main figure {
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }

    /* Ensure gallery main box has a consistent size and vertical alignment for all content */
    .datasets-gallery .datasets-main,
    .datasets-gallery .datasets-main figure,
    .datasets-gallery .datasets-main .datasets-abdo-container {
        width: 100%;
        max-width: 640px;
        aspect-ratio: 4 / 3;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        margin: 0 auto;
    }

    .datasets-gallery .datasets-main img#slide5-datasets-img,
    .datasets-gallery .datasets-main .datasets-abdo-container img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
    }

    /* For the ABDO double layout show two equal-width images inside the same box */
    .datasets-gallery .datasets-main .datasets-abdo-container img {
        width: 49%;
        height: 100%;
        max-height: 100%;
    }

    .datasets-thumb img {
        transition: transform 150ms ease;
    }

    .datasets-thumb[aria-pressed="true"] img {
        outline: 2px solid #0066CC;
        transform: scale(1.02);
    }

    .datasets-prev,
    .datasets-next {
        color: #0066CC;
        background: transparent;
        border: none;
        font-size: 20px;
        padding: 8px;
        cursor: pointer;
    }

    .datasets-prev:focus,
    .datasets-next:focus,
    .datasets-thumb:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    /* AURC explain button and modal styles */
    #slide5-aurc-explain-btn:hover {
        background: #0052A3;
        box-shadow: 0 4px 12px rgba(0, 102, 204, 0.4);
        transform: scale(1.1);
    }

    #slide5-aurc-explain-btn:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    .aurc-modal.show {
        display: flex !important;
    }

    .modal-content {
        animation: slideIn 200ms ease-out;
    }

    @keyframes slideIn {
        from {
            transform: scale(0.95);
            opacity: 0;
        }

        to {
            transform: scale(1);
            opacity: 1;
        }
    }

    .modal-close:hover {
        color: #0066CC;
    }

    .modal-close:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    /* Zoom functionality for AURC figure */
    .aurc-modal img[data-zoomable="true"] {
        cursor: zoom-in;
    }

    .aurc-modal img[data-zoomable="true"].zoomed {
        cursor: zoom-out;
        max-width: none;
        width: 100%;
    }

    /* Reconstruction flow layout (right column with steps + small arrow) */
    .recon-layout {
        display: grid;
        grid-template-columns: 1fr 360px;
        gap: 20px;
        align-items: start;
    }

    .recon-flow .flow-step {
        transition: box-shadow 150ms ease, transform 150ms ease;
    }

    .recon-flow .flow-step:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
        box-shadow: 0 4px 12px rgba(0, 102, 204, 0.12);
        transform: translateY(-2px);
    }

    /* Make reconstruction metric image larger and responsive */
    #slide5-panel-approach img {
        /* changelog: rationale: enlarge approach metric image for better visibility; source: slides/05.html style block */
        max-width: 1400px;
        width: 100%;
        height: auto;
        max-height: 760px;
        display: block;
        margin: 0 auto;
        object-fit: contain;
    }

    /* Center contents of the Results tab both vertically and horizontally */
    #slide5-panel-results>div {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        min-height: 360px;
        text-align: center;
    }

    /* Make the main results figure occupy more vertical space on larger screens */
    #slide5-panel-results img[data-element-id="slide5-img-results"] {
        width: 100%;
        height: auto;
        max-height: 760px;
        object-fit: contain;
        display: block;
        margin: 0 auto;
    }

    .recon-flow .flow-note {
        text-align: center;
    }

    .flow-arrow path {
        opacity: 0.85;
    }

    @media (max-width: 900px) {
        .recon-layout {
            grid-template-columns: 1fr;
        }

        /* on narrow screens, show flow above the image for readability */
        .recon-flow {
            order: -1;
        }

        .recon-image img {
            height: 260px;
        }
    }

    @media (prefers-reduced-motion: reduce) {
        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }

        .datasets-gallery .datasets-main img {
            transition: none !important;
        }

        .datasets-thumb img {
            transition: none !important;
            transform: none !important;
        }
    }
.tab-panel img,

    /* Responsive iframe viewport: contains iframe without internal scrolling */
    .iframe-viewport {
        position: relative;
        overflow: hidden;
        border-radius: 8px;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
    }

    /* Loading overlay shown when user interacts and the iframe is initializing */
    .iframe-loading-overlay .spinner {
        width: 18px;
        height: 18px;
        border: 3px solid rgba(0, 0, 0, 0.12);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 800ms linear infinite;
    }

    @keyframes spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }

    .responsive-iframe {
        border: 0;
        display: block;
        width: 100% !important;
        height: 100% !important;
        min-width: 0;
        box-sizing: border-box;
    }

    /* Zoomed state: handled by JS modal overlay */
    figure[data-zoomable="true"] {
        cursor: zoom-in;
    }

    figure[data-zoomable="true"].zoomed {
        cursor: zoom-out;
    }

    .methods-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
    }

    @media (max-width:720px) {
        .methods-grid {
            grid-template-columns: 1fr;
        }
    }

    .method-visual[data-zoomable="true"] {
        cursor: zoom-in;
    }

    .zoom-hint {
        font-size: 10px;
        color: #666;
        margin-top: 6px;
    }

    .crop-bottom {
        overflow: hidden;
        height: 320px;
        border-radius: 8px;
    }

    .crop-bottom img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        object-position: top center;
        display: block;
    }

    .presenter-notes {
        font-size: 12px;
        color: #555;
        margin-top: 8px;
        padding-left: 8px;
        border-left: 3px solid rgba(0, 0, 0, 0.06);
    }

    .callout-numbers {
        font-size: 12px;
    }

    /* Method steps: reduced color palette and alternating alignment */
    .method-step {
        background: #fafafa;
        border-left: 4px solid #d1d5db;
        padding: 10px;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .method-step .inner {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .method-step .badge {
        background: #6b7280;
        color: #fff;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
        flex-shrink: 0;
    }

    .method-step .content {
        min-width: 0;
    }

    .method-step.align-right .inner {
        flex-direction: row-reverse;
    }

    .method-step.align-right .content {
        text-align: right;
    }

    /* Muted variant accents */
    .method-step.variant-blue {
        border-left-color: #9fb6d9;
    }

    .method-step.variant-blue .badge {
        background: #4f83b8;
    }

    .method-step.variant-green {
        border-left-color: #bcd9c8;
    }

    .method-step.variant-green .badge {
        background: #4b9a6b;
    }

    .method-step.variant-amber {
        border-left-color: #e7d8b5;
    }

    .method-step.variant-amber .badge {
        background: #c5943b;
    }

    .method-step.variant-purple {
        border-left-color: #d6c6e8;
    }

    .method-step.variant-purple .badge {
        background: #8e6ab3;
    }

    @media (prefers-reduced-motion: reduce) {
        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }
    }
@media (prefers-reduced-motion: reduce) {
        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }

        .context-card,
        .context-card:hover,
        .context-hero img {
            transition: none !important;
            transform: none !important;
            box-shadow: none !important;
        }
    }

    .expandable-card:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    .tablist {
        margin: 12px 0;
    }

    .panel-caption {
        font-size: 12px;
        color: #333;
        margin-top: 8px;
    }

    .tabbed-pane {
        padding: 8px 0;
    }

    .tabbed-pane .tab-panel img {
        max-width: 1000px;
        max-height: 760px;
        width: 100%;
        height: auto;
        margin: 0 auto;
        display: block;
    }

    .context-visual-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        grid-template-rows: repeat(2, auto);
        gap: 14px;
        align-items: stretch;
    }

    .context-visual-grid .context-hero {
        grid-column: 1 / -1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, rgba(0, 102, 204, 0.04), rgba(106, 27, 154, 0.05));
        padding: 14px 10px;
        border-radius: 10px;
        border: 1px solid rgba(0, 0, 0, 0.06);
    }

    .context-card {
        display: flex;
        gap: 10px;
        padding: 2px;
        border-radius: 8px;
        border: 1px solid rgba(0, 0, 0, 0.05);
        background: #f7f9fb;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        transition: box-shadow 160ms ease, transform 160ms ease;
    }

    .context-card:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        transform: translateY(-2px);
    }

    .context-card-primary {
        border-left: 4px solid #0066CC;
    }

    .context-card-warning {
        border-left: 4px solid #6A1B9A;
    }

    .context-card-gap {
        border-left: 4px solid #d84315;
    }

    .card-icon {
        width: 34px;
        height: 34px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        background: rgba(0, 102, 204, 0.08);
        color: #004a99;
        font-size: 16px;
    }

    .context-card-warning .card-icon {
        background: rgba(106, 27, 154, 0.08);
        color: #d84315;
    }

    .context-card-gap .card-icon {
        background: rgba(216, 67, 21, 0.1);
        color: #d84315;
    }

    @media (max-width: 900px) {
        .context-visual-grid {
            grid-template-columns: 1fr;
        }

        .context-visual-grid .context-hero {
            grid-column: 1;
        }
    }

    .visually-hidden {
        position: absolute !important;
        width: 1px;
        height: 1px;
        margin: -1px;
        padding: 0;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
        border: 0;
    }

    @media (max-width: 640px) {
        .balanced-grid {
            grid-template-columns: 1fr !important;
        }

        .panel-caption {
            text-align: center;
        }
    }
@media (prefers-reduced-motion: reduce) {
        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }
    }

    /* Center slide content vertically and horizontally */
    .slide-container {
        display: flex;
        flex-direction: column;
        min-height: 100%;
    }

    .slide-container>.ucl-header {
        flex: 0 0 auto;
        width: 100%;
    }

    .slide-container>[data-element-id="slide8-content"] {
        flex: 1 1 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        box-sizing: border-box;
        padding: 30px 28px;
    }

    .expandable-card:focus {
        outline: 2px solid #0066CC;
        outline-offset: 2px;
    }

    .tablist {
        margin: 12px 0;
    }

    .panel-caption {
        font-size: 12px;
        color: #333;
        margin-top: 8px;
    }

    .panel-summary {
        font-size: 13px;
        color: #666;
        margin-top: 8px;
    }

    .tabbed-pane {
        padding: 8px 0;
    }

    .tabbed-pane .tab-panel img {
        max-width: 100%;
        max-height: 480px;
        width: auto;
        height: auto;
        margin: 0 auto;
        display: block;
    }

    .visually-hidden {
        position: absolute !important;
        width: 1px;
        height: 1px;
        margin: -1px;
        padding: 0;
        overflow: hidden;
        clip: rect(0 0 0 0);
        white-space: nowrap;
        border: 0;
    }

    @media (max-width: 640px) {
        .balanced-grid {
            grid-template-columns: 1fr !important;
        }

        [style*="grid-template-columns: 1fr 1.1fr"],
        [style*="grid-template-columns: 1.1fr 1fr"] {
            grid-template-columns: 1fr !important;
        }

        .panel-caption {
            text-align: center;
        }

        [style*="order:1"],
        [style*="order:2"] {
            order: revert !important;
        }
    }
/* Reused generation gallery styles (copied from slide 3) */
                                .generation-gallery .generation-main img {
                                    transition: opacity 200ms ease;
                                    display: block;
                                }

                                .generation-thumb img {
                                    transition: transform 150ms ease;
                                }

                                .generation-thumb[aria-pressed="true"] img {
                                    outline: 2px solid #0066CC;
                                    transform: scale(1.02);
                                }

                                .generation-prev,
                                .generation-next {
                                    color: #0066CC;
                                    background: transparent;
                                    border: none;
                                    font-size: 20px;
                                    padding: 8px;
                                    cursor: pointer;
                                }

                                .generation-prev:focus,
                                .generation-next:focus,
                                .generation-thumb:focus {
                                    outline: 2px solid #0066CC;
                                    outline-offset: 2px;
                                }

                                @media (prefers-reduced-motion: reduce) {

                                    .generation-gallery .generation-main img,
                                    .generation-thumb img {
                                        transition: none !important;
                                        transform: none !important;
                                    }
                                }

                                /* Layout: stack main image above thumbnails */
                                .generation-gallery {
                                    display: flex;
                                    align-items: center;
                                    flex-direction: column;
                                }

                                .generation-gallery .generation-main {
                                    display: flex;
                                    align-items: center;
                                    gap: 8px;
                                }

                                .generation-gallery .generation-thumbs {
                                    display: flex;
                                    flex-direction: row;
                                    gap: 8px;
                                    justify-content: center;
                                    margin-left: 0;
                                    margin-top: 8px;
                                }

                                @media (max-width:720px) {
                                    .generation-gallery {
                                        display: block;
                                        text-align: center;
                                    }

                                    .generation-gallery .generation-main {
                                        flex-direction: row;
                                    }

                                    .generation-gallery .generation-thumbs {
                                        flex-direction: row;
                                        justify-content: center;
                                        margin-left: 0;
                                        margin-top: 8px;
                                    }
                                }

                                .generation-main img {
                                    max-width: 360px;
                                    max-height: 240px;
                                }

                                .generation-thumbs img {
                                    width: 64px;
                                    height: 48px;
                                }
                            

    @media (prefers-reduced-motion: reduce) {
        .fragment {
            transition: none !important;
            animation: none !important;
        }

        .fragment.fade-up {
            transform: none !important;
            opacity: 1 !important;
        }
    }
/* Pillar Card Styling - 3 columns on desktop, responsive stack on small screens */
    .pill-icon {
        font-size: 14px;
        display: inline-block;
        width: 14px;
        height: 14px;
        margin-right: 8px;
        vertical-align: middle;
    }

    .key-takeaway {
        font-weight: 700;
    }

    .pillar-pubs {
        margin-top: 8px;
        font-size: 12px;
        color: #666;
        font-style: italic;
    }

    .pub-icon {
        margin-right: 6px;
        color: #666;
        font-size: 12px;
        vertical-align: middle;
    }

    .pub-status {
        margin-left: 6px;
        font-size: 12px;
        vertical-align: middle;
    }

    .pub-status.published {
        color: #2e7d32;
    }

    .pub-status.pending {
        color: #f57c00;
    }

    /* Future-work subcard styling */
    .future-work {
        margin-top: 8px;
        padding: 8px;
        background: #FFF8E1;
        border-left: 4px solid #FFB74D;
        border-radius: 6px;
        font-size: 12px;
        color: #424242;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .future-icon {
        font-size: 18px;
        line-height: 1;
    }

    /* Layout helpers for the pillars */
    .pillars-container .pillar-card {
        flex: 1 1 0;
        min-width: 220px;
        box-sizing: border-box;
    }

    /* Other credits card: two-column content */
    .other-credits-body {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px 20px;
        align-items: start;
    }

    .other-credits-body .credits-column {
        display: block;
    }

    /* Responsive: stack pillars and credits on narrow screens */
    @media (max-width: 900px) {
        .pillars-container {
            flex-direction: column;
            width: 100% !important;
            gap: 12px;
        }

        .pillars-row-2 {
            width: 100% !important;
            padding: 0 10px;
        }

        .other-credits-body {
            grid-template-columns: 1fr;
        }
    }

    /* Reduced-motion: disable non-essential animations */
    @media (prefers-reduced-motion: reduce) {
        .fragment {
            animation: none !important;
            transition: none !important;
        }
    }
@keyframes bounce-right {

            0%,
            100% {
                transform: translateX(0);
            }

            50% {
                transform: translateX(12px);
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            .fragment {
                transition: none !important;
                animation: none !important;
            }

            .fas.fa-arrow-right {
                animation: none !important;
            }

            #btn_copy_email {
                transition: none !important;
            }
        }

        /* Button hover effects */
        #btn_copy_email:hover {
            background: #BBDEFB !important;
        }

        #btn_copy_email:focus {
            outline: 2px solid #0066CC;
            outline-offset: 2px;
        }

        /* Summary focus */
        #box_followup summary:focus {
            outline: 2px solid #0066CC;
            outline-offset: 2px;
        }
</style>
</head>

<body>
    <div class="slide-wrapper">
        <div id="slides-container">

            <section aria-hidden="true" aria-roledescription="slide" class="slide-container" data-node-id="slide-0" role="group">
<div class="ucl-header">
<!-- changelog: rationale: unify header section title styles; source: slides/00.html L1-L12 -->
<div class="ucl-logo">
<i class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
</div>
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: calc(720px - 140px); padding: 48px; text-align: center;">
<div style="margin-bottom: 32px;">
<i class="fas fa-graduation-cap" style="font-size: 80px; color: #0066CC;"></i>
</div>
<h2 class="slide-title" style="font-size: 36px; font-weight: 700; color: #003366; margin: 0 0 16px 0; line-height: 1.2;">
            Reliable Evaluation of Artificial Intelligence Models
        </h2>
<h2 class="slide-title" style="font-size: 28px; font-weight: 600; color: #003366; margin: 0 0 16px 0; line-height: 1.2;">
            Quality assessment of Segmentation models for Radiotherapy
        </h2>
<div style="display: flex; gap: 24px; margin-top: 32px;">
<div class="kpi-badge">
<i class="fas fa-user-graduate"></i>
<span>Dany Rimez</span>
</div>
<div class="kpi-badge" style="background: linear-gradient(90deg, #003366, #004080);">
<span>UCLouvain</span>
</div>
<div class="kpi-badge" style="background: linear-gradient(90deg, #003366, #004080);">
<span>ICTEAM</span>
</div>
<div class="kpi-badge" style="background: linear-gradient(90deg, #003366, #004080);">
<span>MIRO</span>
</div>
<div class="kpi-badge" style="background: linear-gradient(90deg, #003366, #004080);">
<span>TELEVIE</span>
</div>
</div>
</div>
<div class="progress-container">
<div class="progress-bar" style="width: 4.55%;"></div>
</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — Title &amp; Timing (≈0:20)</h3>
<section>
<h4>Presenter Script (≈0:20)</h4>
<p>Thank you for joining. Briefly introduce yourself and the talk title, then state the objective in one
                sentence: present methods and evidence to make segmentation model evaluation clinically reliable and
                deployable. Mention that timing is tight and that you will be concise.</p>
</section>
<section>
<h4>What I'll Cover (0:10–0:15)</h4>
<ul>
<li>ALCOP: secure, multi-hospital collaboration</li>
<li>CIA: controlled synthetic data and quality assessment</li>
<li>Deep Inversion &amp; VQ‑VAE2: quality management of synthetic data</li>
<li>UQ &amp; Evaluation: reconstruction-based UQ and safety‑constrained calibration</li>
<li>Qually: fingerprint → phantom generator → phantom suite</li>
</ul>
</section>
<section>
<h4>Timing &amp; Pacing (remaining 14.5 minutes)</h4>
<p>Recommended pacing to keep the talk ≈15 minutes total:</p>
<ul>
<li><strong>Slide 01 (Roadmap):</strong> 0:30</li>
<li><strong>Slides 02–06 (ALCOP → UQ):</strong> ~5:00 total (aim ≈1:00 each, ALCOP 1:15)</li>
<li><strong>Slides 07–12 (Qually → Future):</strong> ~6:00 total (aim ≈1:00 per slide)</li>
<li><strong>Slide 13 (Summary):</strong> 1:00</li>
<li><strong>Slide 14 (Q&amp;A):</strong> 2:00</li>
</ul>
<p>Keep answers brief and use the Q&amp;A slot for discussion. If a topic sparks long discussion, suggest a
                follow-up meeting.</p>
</section>
</aside>
</section>

<section aria-roledescription="slide" class="slide-container" data-node-id="intro-motivation" role="group">
<div class="ucl-header">
<!-- changelog: rationale: unify header section title styles; source: slides/01.html header block -->
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div class="header-section-title">Thesis Introduction</div>
</div>
<div style="padding: 24px 28px;">
<!-- Main Title & Subtitle (aligned with Slide 0 & 2) -->
<div style="text-align: left; margin-bottom: 12px; flex: 0 0 auto;">
<h2 class="slide-title">
                Reliable Evaluation of Artificial Intelligence Models
            </h2>
<p class="slide-subtitle">
                Quality assessment of Segmentation models for Radiotherapy
            </p>
</div>
<!-- changelog: rationale: center main content (exclude title/subtitle) for balanced layout; source: slides/01.html (this block) -->
<div style="width: 80%; flex: 1; display: stretch; flex-direction: column; justify-content: center; height: 100%; margin: 48px auto; gap: 12px;">
<div style="margin-top:32px; padding:10px 14px; border-left:4px solid #0b5fff; 
                            background: linear-gradient(90deg, rgba(11,95,255,0.04), transparent); 
                            border-radius:6px; font-size:18px; color:#111; align-items: left;">
                Current AI evaluation relies on <strong>average metrics</strong> (accuracy, Dice scores) and
                <strong>subjective test-set selection</strong>
</div>
<!-- changelog: rationale: improve quote readability with pleasant dark-blue color; source: slides/01.html (quote block) -->
<div data-element-id="testset-quote" style="margin-top:48px; margin-bottom:48px; padding:20px 24px;  
                font-size:28px; line-height:1.1; width:640px; margin-left: auto; text-align: right; font-style: italic; color:#153e75;
                ">
<p style="font-family: 'Times New Roman' , Times, serif;">
                    "Datasets must be relevant, representative, appropriately diverse, and of
                    sufficient quality for their intended purpose."
                </p>
<div aria-hidden="true" class="pillar-pubs" style="margin-top:8px; font-size:10px; color:#666;">
<em>Sources:</em>
<span class="pub-entry">
<i aria-hidden="true" class="fas fa-book pub-icon" title="source"></i>
<span class="pub-text">EU AI Act Article 10 (data quality for high-risk systems)</span>
</span>
<span class="pub-entry">
<span class="pub-text">Gebru et al., "Datasheets for Datasets" (2018)</span>
</span>
<span class="pub-entry">
<span class="pub-text">Mitchell et al., "Model Cards" (2019)</span>
</span>
<span class="pub-entry">
<span class="pub-text">WHO, "AI for Health" (2021)</span>
</span>
<span class="pub-entry">
<span class="pub-text">NIST AI RMF (2023)</span>
</span>
</div>
<!-- changelog: rationale: match citation markup used in slides 02/10 for visual consistency; source: slides/01.html (original sources list) -->
</div>
<div style="margin-top:16px; padding:10px 14px; border-left:4px solid #0b5fff; 
                background: linear-gradient(90deg, rgba(11,95,255,0.04), transparent); 
                border-radius:6px; font-size:18px; color:#111; align-items: left;">
                In radiotherapy, clinicians optimize for <strong>worst-case scenarios</strong>, not averages.
            </div>
</div>
</div>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="10" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 9.09%;"></div>
</div>
<div aria-label="Slide 1" class="slide-counter">1</div>
</section>

<section aria-roledescription="slide" class="slide-container" data-node-id="roadmap-node-thesis-intro" role="group">
<div class="ucl-header">
<!-- changelog: rationale: unify header section title styles; source: slides/02.html header block -->
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div class="header-section-title">Thesis Introduction &amp; Outline</div>
</div>
<div style="padding: 24px 28px; display: flex; flex-direction: column; height: 100%; justify-content: flex-start;">
<!-- Thesis Title & Goal -->
<div style="text-align: left; margin-bottom: 12px; flex: 0 0 auto;">
<h2 class="slide-title">
                Reliable Evaluation of Artificial Intelligence Models
            </h2>
<p class="slide-subtitle">
                Quality assessment of Segmentation models for Radiotherapy
            </p>
</div>
<!-- First row: 3 pillars -->
<!-- changelog: rationale: vertically center pillar cards for improved layout balance; source: slides/02.html (pillars-row-1) -->
<div class="pillars-row-1" style="display: grid; grid-template-columns: 0.3fr 1fr 1fr 1fr 0.3fr; 
            gap: 8px; align-items: center; justify-content: center;
            margin-left:20px; margin-right:20px; margin-top: 48px; margin-bottom: auto;">
<div></div> <!-- spacer column -->
<!-- Pillar 1: QA of Labels -->
<div class="pillar-card fragment fade-up" data-element-id="pillar-1-labels" data-pillar="1" style="animation-delay: 0.1s;">
<div class="pillar-card-header" style="background: #F8F9FA; padding: 14px; border-radius: 8px 8px 0 0; color: #0D47A1; border-bottom: 3px solid #1565C0;">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
<i aria-hidden="true" class="fas fa-image" style="font-size: 16px; color: #1565C0; margin-top:0px; margin-left:0px;"></i>
<i aria-hidden="true" class="fas fa-tags" style="font-size: 16px; color: #1565C0; margin-left:-16px; margin-bottom:8px"></i>
<h3 style="margin: 0; font-size: 18px; font-weight: 700;">Dataset QA</h3>
</div>
<div style="font-size: 12px; line-height: 1.3; font-style: italic; color: #1565C0;">
                        Annotations and Images quality
                    </div>
</div>
<div class="pillar-card-body" style="background: white; padding: 14px; border-radius: 0 0 8px 8px; border: 2px solid #E9ECEF; border-top: none;">
<div style="font-size: 12px; color: #424242; margin: 0; line-height: 1.6;">
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-user-edit pill-icon"></i>
<strong class="key-takeaway">Annotation noise impact</strong>
</div>
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-shield-alt pill-icon"></i>
<strong>Secure annotation peer-review workflows</strong>
</div>
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-search pill-icon"></i>
<strong class="key-takeaway">Outlier detection</strong>
</div>
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-magic pill-icon"></i>
<strong>Improve AI models performances with GenAI</strong>
</div>
<!-- changelog: added publication icons + placeholder status indicators; requires_human_approval: true -->
<div aria-hidden="true" class="pillar-pubs" style="margin-top:8px; font-size:12px; color:#666; grid-column: 1 / -1;">
<span class="pub-entry authored">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Rimez, Legay &amp; Macq — NiDS 2024</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span>
<span class="pub-entry">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Benkedadra, Rimez et al. — MIPR 2024</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span>
</div>
</div>
</div>
</div>
<!-- Pillar 2: Prediction QA -->
<div class="pillar-card fragment fade-up" data-element-id="pillar-3-predictions" data-pillar="3" style="animation-delay: 0.2s;">
<div class="pillar-card-header" style="background: #F8F9FA; padding: 14px; border-radius: 8px 8px 0 0; color: #4527A0; border-bottom: 3px solid #5E35B1;">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
<i aria-hidden="true" class="fas fa-chart-line" style="font-size: 24px; color: #5E35B1;"></i>
<h3 style="margin: 0; font-size: 18px; font-weight: 700;">Prediction QA</h3>
</div>
<div style="font-size: 12px; line-height: 1.3; color: #5E35B1; font-style: italic;">
                        Quantify and predict the quality of model predictions
                    </div>
</div>
<div class="pillar-card-body" style="background: white; padding: 14px; border-radius: 0 0 8px 8px; border: 2px solid #E9ECEF; border-top: none;">
<div style="font-size: 12px; color: #424242; margin: 0; line-height: 1.6;">
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-chart-line pill-icon"></i>
<strong class="key-takeaway">Calibrated uncertainty metrics</strong>
</div>
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-exclamation-triangle" style="font-size: 14px; color: #5E35B1;"></i>
<strong style="margin-left: 8px; color: #5E35B1;">Flagging segmentation errors</strong>
</div>
<!-- changelog: added publication icons + placeholder status indicators; requires_human_approval: true -->
<div aria-hidden="true" class="pillar-pubs" style="margin-top:8px; font-size:12px; color:#666;">
<span class="pub-entry authored">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Rimez, J.A. Lee &amp; A-M. B-M. — ESTRO 2026</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span>
</div>
</div>
</div>
</div>
<!-- PILLAR 3: COMPREHENSIVE MODEL QA -->
<div class="pillar-card fragment fade-up" data-element-id="pillar-3-predictions" data-pillar="3" style="animation-delay: 0.2s;">
<div class="pillar-card-header" style="background: #F8F9FA; padding: 14px; border-radius: 8px 8px 0 0; color: #7B1FA2; border-bottom: 3px solid #5E35B1;">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
<i aria-hidden="true" class="fas fa-microscope" style="font-size: 24px; color: #7B1FA2; 
                        margin-bottom: 6px; margin-right: 4px;"></i>
<h3 style="font-size: 18px; font-weight: 700; color: #6A1B9A;">
                            Model QA<br/>
</h3>
</div>
<div style="font-size: 12px; line-height: 1.3; color: #7B1FA2; font-style: italic;">
                        Comprehensive characterization of model performances
                    </div>
</div>
<div class="pillar-card-body" style="background: white; padding: 14px; border-radius: 0 0 8px 8px; border: 2px solid #E9ECEF; border-top: none;">
<div style="font-size: 11px; color: #424242; margin: 0 0 10px 0; line-height: 1.5;">
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-vial pill-icon"></i>
<strong class="key-takeaway">Systematic robustness benchmarks</strong>
</div>
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-user-md pill-icon"></i>
<strong>Clinical-use scenario testing</strong>
</div>
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-tasks pill-icon"></i>
<strong>End-to-end evaluation methods</strong>
</div>
<div style="display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-rocket" style="font-size: 14px; color: #7B1FA2;"></i>
<strong style="margin-left: 8px; color: #7B1FA2;">Clinical decision workflows</strong>
</div>
<!-- Publications -->
<span class="pub-entry authored" style="display: block; margin-top: 4px;">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Rimez, J.A. Lee &amp; A-M. B-M. — ESANN 2026</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span>
</div>
</div>
</div>
<div></div> <!-- spacer column -->
</div>
</div>

<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="20" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 13.64%;"></div>
</div>
<div aria-label="Slide 2" class="slide-counter">2</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — Thesis Introduction &amp; Roadmap (≈1:30)</h3>
<section>
<h4>Presenter Script (≈1:30)</h4>
<p>This talk opens with the current project: Comprehensive Model QA — a practical pipeline to evaluate,
                validate and prepare segmentation models for integration in radiotherapy workflows. The horizontal card
                on the slide represents this ongoing work (robustness testing, clinical applicability, thorough
                evaluation, and near-term integration &amp; deployment). The three pillar cards below summarize prior
                research that directly support the current project: label QA (annotation noise, secure peer-review,
                cybersecurity), image QA (augmentation, outlier detection, data validation) and prediction QA
                (uncertainty quantification and risk-aware deployment). These past studies produced methods and
                publications that feed into the comprehensive model QA pipeline shown here. See the key
                references listed under each pillar for representative publications.</p>
</section>
<section>
<h4>Key Concepts</h4>
<ul>
<li><strong>Model QA (current):</strong> Evaluate model robustness, generalisation and clinical
                    readiness.</li>
<li><strong>Label Quality:</strong> Assess annotation noise and improve annotation workflows.</li>
<li><strong>Image Validation:</strong> Ensure consistent image quality; use augmentation and outlier
                    detection.</li>
<li><strong>Prediction Uncertainty:</strong> Quantify confidence to support risk-aware decisions.</li>
<li><strong>Publications &amp; outputs:</strong> Prior work produced methods and papers that feed into the
                    current project.</li>
</ul>
</section>
</aside>
</section>
<!-- changelog: rationale: reduce width of first two pillar columns to improve balance; source: slides/02.html (style .pillars-row-1) -->


<section aria-roledescription="slide" class="slide-container" data-node-id="roadmap-node-cia" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div aria-label="Slide status" class="status-banner" style="margin-left: auto; display:flex; gap:8px; align-items:center;">
<!-- changelog: rationale: use unified badge styling; source: slides/03.html header -->
<span class="status-badge published">
<i aria-hidden="true" class="fas fa-upload"></i> Published — IEEE MIPR 2024
            </span>
</div>
</div>
<div style="padding: 20px 28px;">
<div style="display: flex; gap: 12px; align-items: flex-start; justify-content: space-between;">
<div style="flex: 1;">
<h2 class="slide-title fragment fade-up" data-element-id="slide3-title">
<i aria-hidden="true" class="fas fa-wand-magic-sparkles" style="color: #0066CC; margin-right: 12px;"></i>
                    Controllable Image Augmentation
                </h2>
<p class="slide-subtitle fragment fade-up" style="margin:0; font-size:16px;">
                    Improving object detection
                    performance in low-data regimes with ControlNet and Stable Diffusion</p>
</div>
<div aria-label="CIA tabs" class="tablist" role="tablist">
<button aria-controls="slide3-panel-intro" aria-selected="true" class="tab active" id="slide3-tab-intro" role="tab"><i aria-hidden="true" class="fas fa-info-circle"></i>Intro</button>
<button aria-controls="slide3-panel-controlnet" aria-selected="false" class="tab" id="slide3-tab-controlnet" role="tab"><i aria-hidden="true" class="fas fa-network-wired"></i>ControlNet</button>
<button aria-controls="slide3-panel-methods" aria-selected="false" class="tab" id="slide3-tab-methods" role="tab"><i aria-hidden="true" class="fas fa-cogs"></i>Methods</button>
<button aria-controls="slide3-panel-results" aria-selected="false" class="tab" id="slide3-tab-results" role="tab"><i aria-hidden="true" class="fas fa-chart-bar"></i>Results</button>
</div>
</div>
<div class="tabbed-pane" data-element-id="slide3-tabs" style="margin-top: 16px;">
<div class="tab-panels">
<div aria-hidden="false" aria-labelledby="slide3-tab-intro" class="tab-panel" data-element-id="slide3-panel-intro" id="slide3-panel-intro" role="tabpanel">
<div style="animation-delay:0.1s; gap:48px; margin-bottom:48px;
                                        display: grid; grid-template-columns: 1fr 1fr; max-width:100%; max-height:100%; align-items:center">
<div>
<div class="objective-box" style="background:#f0f8ff; border-left:4px solid #0066CC; padding:12px; border-radius:6px; margin:12px 0;">
<h4 style="margin:0 0 8px 0; color:#0066CC; font-weight:700;">Objective</h4>
<p style="font-size:14px; color:#003a66; margin:0; line-height:1.6;">
                                    Generate <strong>task-aligned</strong> synthetic images that improve detection model
                                    under
                                    data scarcity &amp; low diversity constraints.
                                </p>
</div>
<div class="tech-stack" style="display:grid; margin:12px 0;">
<div class="tech-item" style="display:flex; align-items:start; gap:10px; padding:8px; background:#f9f9f9; border-radius:6px;">
<div style="min-width:24px;"><i aria-hidden="true" class="fas fa-magic" style="color:#0066CC;"></i>
</div>
<div>
<strong style="color:#0066CC;">Stable Diffusion</strong><br/>
<span style="font-size:13px; color:#666;">Promptable text-to-image generative
                                            model</span>
</div>
</div>
<div class="tech-item" style="display:flex; align-items:start; gap:10px; padding:8px; background:#f9f9f9; border-radius:6px;">
<div style="min-width:24px;"><i aria-hidden="true" class="fas fa-network-wired" style="color:#0066CC;"></i></div>
<div>
<strong style="color:#0066CC;">ControlNet</strong><br/>
<span style="font-size:13px; color:#666;">Condition generation on structural
                                            cues (pose, edges, segmentation)</span>
</div>
</div>
<div class="tech-item" style="display:flex; align-items:start; gap:10px; padding:8px; background:#f9f9f9; border-radius:6px;">
<div style="min-width:24px;"><i aria-hidden="true" class="fas fa-filter" style="color:#0066CC;"></i>
</div>
<div>
<strong style="color:#0066CC;">Quality Filtering</strong><br/>
<span style="font-size:13px; color:#666;">Image quality or active sampling
                                            metrics</span>
</div>
</div>
</div>
</div>
<figure class="fragment fade-up method-visual" style="max-width:100%; max-height:560px; object-fit: contain; " data-zoomable="true">
<img alt="CIA framework overview" class="slide3-intro-image" loading="lazy" src="../CIA/CIA_intro.svg" style="width:100%; max-height:560px; height:auto; display:block;"/>
<figcaption style="margin-top: 8px; font-size: 13px; color: #666; text-align: center;">CIA
                                framework applied to human detection</figcaption>
</figure>
</div>
</div>
<div aria-hidden="true" aria-labelledby="slide3-tab-controlnet" class="tab-panel" data-element-id="slide3-panel-controlnet" hidden="" id="slide3-panel-controlnet" role="tabpanel">
<div>
<div style="display:grid; grid-template-columns:1.2fr 1fr; gap:16px; margin:12px 0;">
<div class="what-box" style="background:linear-gradient(135deg, #e0f2fe 0%, #f0f9ff 100%); padding:16px; border-radius:8px; border-left:4px solid #0066CC;">
<h4 style="margin:0 0 8px 0; color:#0066CC; display:flex; align-items:center; gap:8px; font-weight:700;">
<i aria-hidden="true" class="fas fa-question-circle"></i> ControlNet
                                </h4>
<ul style="margin:0; padding-left:18px; font-size:16px; color:#003a66; line-height:1.6;">
                                    Condition stable diffusion model with structural cues to conserve them in generated
                                    images.
                                </ul>
</div>
<div class="benefit-box" style="background:linear-gradient(135deg, #dcfce7 0%, #f0fdf4 100%); padding:16px; border-radius:8px; border-left:4px solid #16a34a;">
<h4 style="margin:0 0 8px 0; color:#16a34a; display:flex; align-items:center; gap:8px; font-weight:700;">
<i aria-hidden="true" class="fas fa-thumbs-up"></i> Key Benefit
                                </h4>
<ul style="margin:0; padding-left:18px; font-size:14px; color:#14532d; line-height:1.6;">
<strong>Preserve chosen features</strong> while increasing appearance diversity
</ul>
</div>
</div>
<div class="controlnet-pipeline-grid" style="margin-left:20px; margin-right:40px; margin-top:24px; margin-bottom:12px;">
<div class="pipeline-step" role="listitem">
<div class="icon-circle"><i aria-hidden="true" class="fas fa-image"></i></div>
<div class="step-label">Original</div><br/>
<div><figure aria-label="intro_original.png" class="method-visual" data-zoomable="true" style="max-height:640px; margin:0; display:inline-block;"><img loading="lazy" src="../CIA/intro_original.png" style="width:160px;height:160px;border-radius:4px;object-fit:contain;"/><figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure></div>
</div>
<div aria-hidden="true" class="pipeline-arrow">→</div>
<div class="pipeline-step" role="listitem">
<div class="icon-circle"><i aria-hidden="true" class="fas fa-vector-square"></i></div>
<div class="step-label">Extraction</div><br/>
<div>
<figure aria-label="intro_edges.png" class="method-visual" data-zoomable="true" style="max-height:640px; margin:0; display:inline-block;"><img loading="lazy" src="../CIA/intro_edges.png" style="width:160px;height:160px;border-radius:4px;object-fit:contain;"/><figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
</div>
<div class="step-keywords">Edges</div>
</div>
<div aria-hidden="true" class="pipeline-arrow">→</div>
<div class="pipeline-step" role="listitem">
<div class="icon-circle"><i aria-hidden="true" class="fas fa-wand-magic-sparkles"></i>
</div>
<div class="step-label">Generation</div>
<div style="text-align:center; margin-top:6px;">
<div aria-label="Generation examples gallery" class="generation-gallery" role="region" style="display:flex; flex-direction:row; align-items:center;justify-content:center;gap:12px;" tabindex="0">
<div class="generation-main" style="position:relative; display:flex; align-items:center; justify-content:center;">
<button aria-label="Previous generated image" class="generation-prev" style="background:none;border:none;cursor:pointer;font-size:26px;line-height:1;padding:6px 10px;" role="button" tabindex="0">‹</button>
<div style="text-align:center;">
<figure aria-label="intro_kimkardashian.png" class="method-visual" data-zoomable="true" style="max-height:640px; margin:0; display:inline-block;"><img id="slide3-gen-main" loading="lazy" src="../CIA/intro_kimkardashian.png" style="width:160px;height:160px;object-fit:contain;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1);"/><figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
<p class="panel-caption" id="slide3-gen-caption" style="margin-top:8px;">
                                                    Example outputs · varied prompts</p>
</div>
<button aria-label="Next generated image" class="generation-next" style="background:none;border:none;cursor:pointer;font-size:26px;line-height:1;padding:6px 10px;" role="button" tabindex="0">›</button>
</div>
<div class="generation-thumbs" role="list" style="display:flex;flex-direction:column;gap:8px;justify-content:center;margin-left:8px;">
<button aria-label="Show Kim Kardashian" aria-pressed="true" class="generation-thumb" data-caption="Kim Kardashian" data-src="../CIA/intro_kimkardashian.png" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="Kim thumbnail" loading="lazy" src="../CIA/intro_kimkardashian.png" style="width:48px;height:48px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show Sandra Oh" aria-pressed="false" class="generation-thumb" data-caption="Sandra Oh" data-src="../CIA/intro_sandraoh.png" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="Sandra thumbnail" loading="lazy" src="../CIA/intro_sandraoh.png" style="width:48px;height:48px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show Rhianna" aria-pressed="false" class="generation-thumb" data-caption="Rhianna" data-src="../CIA/intro_rhianna.png" style="border:none;background:none;cursor:0;padding:0;" role="button" tabindex="0">
<img alt="Rhianna thumbnail" loading="lazy" src="../CIA/intro_rhianna.png" style="width:48px;height:48px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show Taylor Swift" aria-pressed="false" class="generation-thumb" data-caption="Taylor Swift" data-src="../CIA/intro_taylorswift.png" style="border:none;background:none;cursor:0;padding:0;" role="button" tabindex="0">
<img alt="Taylor thumbnail" loading="lazy" src="../CIA/intro_taylorswift.png" style="width:48px;height:48px;object-fit:cover;border-radius:4px;"/>
</button>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div aria-hidden="true" aria-labelledby="slide3-tab-methods" class="tab-panel" data-element-id="slide3-panel-methods" hidden="" id="slide3-panel-methods" role="tabpanel" style="margin-top:-16px;">
<div style="margin-top:-16px; margin-bottom:-16px; align-items: center;">
<div style="margin-top:-16px;">
<div aria-label="CIA Augmentation Pipeline" class="pipeline-graphic" role="list" style="margin-top:8px; margin-bottom:12px;">
<div class="pipeline-step" role="listitem">
<div class="icon-circle"><i aria-hidden="true" class="fas fa-crop-alt"></i></div>
<div class="step-label">Extract</div>
<div class="step-keywords">pose · edges · segmentation</div>
</div>
<div aria-hidden="true" class="pipeline-arrow">→</div>
<div class="pipeline-step" role="listitem">
<div class="icon-circle"><i aria-hidden="true" class="fas fa-wand-magic-sparkles"></i>
</div>
<div class="step-label">Generate</div>
<div class="step-keywords">Stable Diffusion + ControlNet; synthetic prompts</div>
</div>
<div aria-hidden="true" class="pipeline-arrow">→</div>
<div class="pipeline-step" role="listitem">
<div class="icon-circle"><i aria-hidden="true" class="fas fa-filter"></i></div>
<div class="step-label">Filter</div>
<div class="step-keywords">BRISQUE · NIMA · ClipIQA · diversity sampling</div>
</div>
<div aria-hidden="true" class="pipeline-arrow">→</div>
<div class="pipeline-step" role="listitem">
<div class="icon-circle"><i aria-hidden="true" class="fas fa-tag"></i></div>
<div class="step-label">Label</div>
<div class="step-keywords">inherit original bounding boxes</div>
</div>
</div>
<div aria-live="polite" class="sr-only">Note: synthetic images inherit the original
                                bounding-box annotations without manual relabeling.</div>
</div>
<!-- changelog: rationale: center CIA pipeline figure horizontally; source: slides/03.html#L257-L263 -->
<figure style="height:480px !important; max-width:55%; margin:0 auto; display:flex; 
                            justify-content:center; margin-top:-16px; align-items:center; background:none; object-fit:contain;" class="method-visual" data-zoomable="true">
<img alt="CIA pipeline diagram" loading="lazy" src="../CIA/CIA3.png" style="max-width:100%; height:100%; display:block; background:none;"/>
<figcaption></figcaption>
</figure>
</div>
</div>
<div aria-hidden="true" aria-labelledby="slide3-tab-results" class="tab-panel" data-element-id="slide3-panel-results" hidden="" id="slide3-panel-results" role="tabpanel">
<div style="display: grid; grid-template-columns: 1fr 1.5fr; gap: 24px; align-items: center;">
<div>
<div class="critical-insight fragment fade-up" style="animation-delay: 0.3s; background:linear-gradient(90deg, #fef3c7 0%, #fef9e7 100%); border-left:5px solid #f59e0b; padding:14px; border-radius:8px; margin:12px 0;">
<h4 style="margin:0 0 8px 0; color:#92400e; display:flex; align-items:center; gap:8px; font-size:15px; font-weight:700;">
<i aria-hidden="true" class="fas fa-bolt"></i> ControlNet Choice is Critical
                                </h4>
<ul style="font-size:13px; color:#78350f; margin-left:12px; line-height:1.6; padding-left:18px;">
<li>Task-aligned extractors — <strong>+10% mAP</strong></li>
<li>Misaligned extractors — label · content mismatch</li>
</ul>
</div>
<div class="surprising-finding fragment fade-up" style="animation-delay: 0.3s; margin-top:16px; background:#faf5ff; border:2px dashed #9333ea; padding:12px; border-radius:8px;">
<div style="font-size:13px; color:#581c87; margin-left:12px; line-height:1.6;">
<div style="display:flex; align-items:center; gap:8px;"><i aria-hidden="true" class="fas fa-lightbulb"></i><strong>Task alignment &gt; Quality
                                            filtering</strong>
</div>
<ul style="margin:8px 0 0 18px; padding:0;">
<li>Image Quality (BRISQUE · NIMA · ClipIQA) ≈ random</li>
<li>Diversity or model confidence ≈ random</li>
</ul>
</div>
</div>
<div class="takeaway" style="margin:12px 0;"><strong>Bottom line:</strong> +100%
                                task-aligned ·
                                ≈ doubling real data</div>
<details class="metrics" style="margin-top:18px; display: left">
<summary style="font-weight:700; cursor:pointer;"><i aria-hidden="true" class="fas fa-file" style="margin-right:8px;"></i> Details
                                </summary>
<div style="margin-top:8px; font-size:13px;">
<p style="margin:0 0 6px 0;"><strong>Authors:</strong> Benkedadra, M., Rimez, D.,
                                        Godelaine, T., <i>et al.</i></p>
<p style="margin:0 0 6px 0;"><strong>Paper:</strong> <a href="https://doi.org/10.1109/MIPR62202.2024.00102" rel="noopener noreferrer" target="_blank"><i aria-hidden="true" class="fas fa-book"></i>
                                            IEEE MIPR 2024 (DOI: 10.1109/MIPR62202.2024.00102)</a></p>
<p style="margin:0 0 6px 0;"><strong>Code:</strong> <a href="https://github.com/multitel-ai/CIA" rel="noopener noreferrer" target="_blank"><i aria-hidden="true" class="fas fa-code-branch"></i>
                                            github.com/multitel-ai/CIA</a></p>
</div>
</details>
</div>
<div>
<figure class="fragment fade-up method-visual" style="margin:0; text-align:center;" data-zoomable="true">
<img alt="Fig.4 — mAP comparison across ControlNet variants and augmentation levels (COCO/Flickr)." aria-describedby="slide3-results-desc" id="slide3-results-fig" loading="lazy" src="../CIA/page005_image001.jpg" style="width:100%; height:auto; max-height:560px; object-fit:contain; border-radius:6px;"/>
<figcaption id="slide3-results-desc" style="font-size:12px; color:#333; margin-top:8px;">
                                    Fig.4 — mAP comparison across ControlNet variants and augmentation levels
                                    (COCO/Flickr).
                                </figcaption>
</figure>
</div>
</div>
<div aria-live="polite" class="sr-only" id="slide3-results-metric">Reported: +3.2% mAP (YOLOv8n on
                        COCO person subset). Improvements generalize across ControlNet variants that preserve
                        label-aligned features; IQA metrics did not increase selection efficiency.</div>
</div>
</div>
</div>
</div>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="30" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 18.18%;"></div>
</div>
<div aria-label="Slide 3" class="slide-counter">3</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — CIA (≈1:30)</h3>
<section>
<h4>Presenter Script (≈1:30)</h4>
<p>CIA (Controllable Image Augmentation) addresses a critical challenge in computer vision: improving object
                detection when you have limited, low-diversity data. We combine Stable Diffusion with ControlNet to
                generate task-aligned synthetic images. The key insight is that we extract structural features (pose,
                edges, or segmentation masks) from real images, condition the generation on these features, and filter
                the results using quality metrics. Our case study on human detection using the COCO person subset shows
                that adding ~750 synthetic images improves mAP by up to 3.2%—approaching performance gains equivalent to
                doubling the real dataset. Crucially, the choice of ControlNet matters: OpenPose and Canny Edge work
                better than less specialized extractors.</p>
</section>
<section>
<h4>Backup: Intro &amp; Motivation</h4>
<ul>
<li><strong>Problem:</strong> Deep learning requires large, diverse, annotated datasets. Scarcity limits
                    performance, especially for specialized tasks.</li>
<li><strong>Goal:</strong> Generate privacy-aware synthetic data that improves detection in low-data,
                    low-diversity regimes.</li>
<li><strong>Why it matters:</strong> Enables practical deployment where large datasets are unavailable.
                </li>
</ul>
</section>
<section>
<h4>Backup: Tools</h4>
<ul>
<li><strong>Stable Diffusion:</strong> Text-to-image generative model; flexible, quality output.</li>
<li><strong>ControlNet:</strong> Conditions Stable Diffusion on structural cues (pose, edges,
                    segmentation) to maintain object locations and configurations.</li>
<li><strong>Dataset (COCO):</strong> We use only images with single 'person' instances (5–80% of image
                    area) to create a controlled evaluation scenario.</li>
<li><strong>Quality Metrics:</strong> BRISQUE, NIMA, ClipIQA assess synthetic image quality; active
                    learning methods (CORE-SET) identify informative samples.</li>
</ul>
</section>
<section>
<h4>Backup: Methods</h4>
<ul>
<li><strong>Step 1 (Extract):</strong> Choose a ControlNet extractor (OpenPose, Canny Edge,
                    Segmentation, MediaPipe) and extract features from real images.</li>
<li><strong>Step 2 (Generate):</strong> Use Stable Diffusion conditioned on extracted features + text
                    prompts. Prompts are modified via vocabulary substitution to create diversity.</li>
<li><strong>Step 3 (Filter):</strong> Apply quality metrics (optional) and select high-quality samples
                    for training.</li>
<li><strong>Modularity:</strong> Each component can be swapped (different extractors, Diffusion models,
                    quality metrics).</li>
</ul>
</section>
<section>
<h4>Backup: Results &amp; Conclusions</h4>
<ul>
<li><strong>The chart shows a clear split:</strong> Task-appropriate ControlNets (Canny, OpenPose)
                    outperform generic ones (MediaPipe, Dwpose). The key insight is that bad ControlNet choices create a
                    mismatch: the bounding boxes inherited from the real image no longer align with the synthetic
                    content generated by a poorly-aligned extractor. The detector learns corrupted signal—no
                    improvement.</li>
<li><strong>ROI:</strong> ~750 synthetic samples yield best return; plateau visible in the chart.</li>
<li><strong>Why label alignment matters:</strong> If ControlNet distorts object structure (e.g.,
                    MediaPipe shifts limbs incorrectly), the inherited bounding boxes become wrong. Standard
                    augmentation already helps, so only <em>aligned</em> synthetic data adds value.</li>
<li><strong>Quality filtering lesson:</strong> Surprisingly, random sampling ≈ BRISQUE, NIMA, CORE-SET.
                    Suggests diversity matters more than perceived image quality.</li>
<li><strong>Conclusion:</strong> CIA is an extensible framework. Key lesson: **task alignment (via
                    ControlNet) &gt; post-hoc filtering**. Applicable to segmentation, classification, and other CV tasks.
                </li>
</ul>
</section>
</aside>
</section>
<script>
    // toggleFragment deprecated: replaced by native <details> elements for accessible expansion.
    // Use <details><summary>…</summary><div>…</div></details> for interactive cards.

    // Slide-specific augmentation for slide 3 (CIA)
    // The global initializer wires tab behavior; here we only perform slide-specific accessibility tasks
    (function () {
        const root = document.querySelector('[data-element-id="slide3-tabs"]');
        if (!root) return;
        const tabs = Array.from(root.querySelectorAll('[role="tab"]'));

        function onSelectedTab(tab) {
            if (!tab) return;
            const panelId = tab.getAttribute('aria-controls');
            if (panelId === 'slide3-panel-results') {
                const heading = document.getElementById('slide3-results-heading');
                const metric = document.getElementById('slide3-results-metric');
                if (heading) heading.focus();
                if (metric) metric.textContent = '+3.2% mAP (YOLOv8n on COCO — see full table).';
            } else if (panelId === 'slide3-panel-controlnet') {
                const heading = document.getElementById('slide3-controlnet-heading');
                if (heading) heading.focus();
            }
        }

        // Run for the initially selected tab
        const initial = tabs.find(t => t.getAttribute('aria-selected') === 'true') || tabs[0];
        if (initial) onSelectedTab(initial);

        // Observe aria-selected changes on tabs to trigger accessibility updates
        tabs.forEach(tab => {
            const obs = new MutationObserver(muts => {
                muts.forEach(m => {
                    if (m.type === 'attributes' && m.attributeName === 'aria-selected') {
                        if (tab.getAttribute('aria-selected') === 'true') onSelectedTab(tab);
                    }
                });
            });
            obs.observe(tab, { attributes: true });
        });

        // Generation gallery: thumbnails, prev/next, keyboard navigation (ControlNet tab)
        (function initControlNetGallery() {
            const panel = document.querySelector('#slide3-panel-controlnet');
            if (!panel) return;
            const gallery = panel.querySelector('.generation-gallery');
            if (!gallery) return;
            const main = gallery.querySelector('#slide3-gen-main');
            const caption = gallery.querySelector('#slide3-gen-caption');
            const thumbs = Array.from(gallery.querySelectorAll('.generation-thumb'));
            const prev = gallery.querySelector('.generation-prev');
            const next = gallery.querySelector('.generation-next');
            let index = 0;
            const update = i => {
                const btn = thumbs[i];
                const src = btn.getAttribute('data-src');
                const cap = btn.getAttribute('data-caption');
                main.src = src;
                main.alt = btn.querySelector('img').alt;
                caption.textContent = cap;
                thumbs.forEach((t, idx) => t.setAttribute('aria-pressed', idx === i ? 'true' : 'false'));
                index = i;
            };
            thumbs.forEach((t, i) => {
                t.addEventListener('click', () => update(i));
                t.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); update(i); } });
            });
            prev && prev.addEventListener('click', () => update((index - 1 + thumbs.length) % thumbs.length));
            next && next.addEventListener('click', () => update((index + 1) % thumbs.length));
            gallery.addEventListener('keydown', e => {
                if (e.key === 'ArrowLeft') prev && prev.click();
                if (e.key === 'ArrowRight') next && next.click();
            });
            // initialize
            update(0);
        })();
    })();
</script>

<section aria-roledescription="slide" class="slide-container" data-node-id="roadmap-node-uq-sota" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div aria-label="Slide status" class="status-banner" style="margin-left: auto; display:flex; gap:8px; align-items:center;">
<span class="status-badge accepted" style="margin-right: 8px; font-size: 11px;">
<i aria-hidden="true" class="fas fa-check-circle"></i> Uncertainty Quantification
            </span>
</div>
</div>
<div style="padding: 20px 28px;">
<div style="display:flex; align-items:flex-start; justify-content:space-between; gap:16px;">
<div style="flex:1;">
<h2 class="slide-title fragment fade-up" data-element-id="slide4-title">
<i aria-hidden="true" class="fas fa-question-circle" style="color: #0066CC; margin-right: 12px;"></i>
                    Uncertainty Quantification in Medical Segmentation
                </h2>
<p class="slide-subtitle fragment fade-up">Models are <em>unpredictably unreliable</em></p>
</div>
<div aria-label="UQ SOTA tabs" class="tablist" role="tablist">
<button aria-controls="slide4-panel-uq" aria-selected="true" class="tab active" id="slide4-tab-uq" role="tab"><i aria-hidden="true" class="fas fa-lightbulb"></i>Overview</button>
<button aria-controls="slide4-panel-methods" aria-selected="false" class="tab" id="slide4-tab-methods" role="tab"><i aria-hidden="true" class="fas fa-flask-vial"></i>Bayesian
                    Approaches</button>
</div>
</div>
<div class="tabbed-pane" data-element-id="slide4-tabs" style="margin-top: 4px;">
<div class="tab-panels">
<!-- TAB 1: Overview -->
<div aria-hidden="false" class="tab-panel" data-element-id="slide4-panel-uq" id="slide4-panel-uq" role="tabpanel">
<div style="margin-top: 24px;">
<div style="display: grid; grid-template-columns: 8% 480px 4% 1fr 8%; gap:16px; align-items: center;">
<div></div>
<figure class="fragment fade-up method-visual" style="width:100%; max-height:320px; border-radius:8px; object-fit:contain;" data-zoomable="true">
<img alt="" data-src="../ESTRO/metric_new.svg" id="slide4-dice-img" loading="lazy" role="img" src="../ESTRO/metric_new.svg" style="width:100%; max-height:100%; display:block"/>
<figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
<div></div>
<div>
<div class="uq-definition">
<p style="font-size:17px; font-weight:600; color:#0066CC; margin-bottom:12px;">
                                        The Problem: Variable Prediction Quality</p>
<p><strong>The issue:</strong> A segmentation might be 90% accurate or 40%
                                        accurate. You can't tell which without ground truth.</p>

</div>
<div style="flex:1; padding:12px 16px; background:rgba(0,102,204,0.04); border-radius:8px; border-left:3px solid #0066CC; margin-top:32px;">
<p style="margin:0; font-size:14px; color:#333; line-height:1.6;">
<i aria-hidden="true" class="fas fa-lightbulb" style="margin-right:8px;"></i>
<span style="font-size:13px; color:#666;">Uncertainty Quantification aims to
                                            identify
                                            errors and trust good predictions</span>
</p>
</div>
</div>
<div></div>
</div>
</div>
</div>
<!-- TAB 2: Bayesian Approaches -->
<div aria-hidden="true" class="tab-panel" data-element-id="slide4-panel-methods" hidden="" id="slide4-panel-methods" role="tabpanel">
<div class="fragment fade-up" style="animation-delay:0.25s; padding:14px 16px; background:#E8F4FF; 
                        border-radius:8px; border-left:4px solid #0066CC; display:flex; 
                        align-items:flex-start; gap:12px; margin-left: 12px;">
<i aria-hidden="true" class="fas fa-info-circle" style="font-size:20px; color:#0066CC; margin-top:2px;"></i>
<div>
<p style="font-size:14px; color:#333; margin:0 0 4px 0; font-weight:600;">
                                Key concept: Prediction Variability
                            </p>
<p style="font-size:13px; color:#333; margin:0;">
                                All methods generate several predictions for a given input.
                                Variability (entropy, variance,
                                disagreement) across predictions quantifies uncertainty.
                            </p>
</div>
</div>
<div class="methods-layout" id="methods-grid" style="margin-top: 12px;">
<div class="methods-buttons-container">
<!-- MCDO -->
<button aria-label="MCDO method — Monte Carlo Dropout" aria-pressed="false" class="method-button fragment fade-up active" data-method="mcdo" style="animation-delay:0.1s;" role="button" tabindex="0">
<div class="card">
<div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:8px;">
<h4 style="margin:0; color:#0066CC; display:flex; align-items:center; gap:6px;">
<i aria-hidden="true" class="fas fa-random"></i>
<span class="method-title">MCDO</span>
</h4>
</div>
<p class="method-desc" style="margin:0; font-size:13px; line-height:1.4;">
                                        Randomly inactivated weights at test time generates non-deterministic
                                        predictions
                                    </p>
</div>
</button>
<!-- Deep Ensembles -->
<button aria-label="Deep Ensembles method — ensemble disagreement" aria-pressed="false" class="method-button fragment fade-up" data-method="ensemble" style="animation-delay:0.15s;" role="button" tabindex="0">
<div class="card">
<div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:8px;">
<h4 style="margin:0; color:#0066CC; display:flex; align-items:center; gap:6px;">
<i aria-hidden="true" class="fas fa-layer-group"></i>
<span class="method-title">Ensembles</span>
</h4>
</div>
<p class="method-desc" style="margin:0; font-size:13px; line-height:1.4;">
                                        Multiple models trained independently with different
                                        initializations.
                                    </p>
</div>
</button>
<!-- TTA -->
<button aria-label="Test-time augmentation method — TTA" aria-pressed="false" class="method-button fragment fade-up" data-method="tta" style="animation-delay:0.2s;" role="button" tabindex="0">
<div class="card">
<div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:8px;">
<h4 style="margin:0; color:#0066CC; display:flex; align-items:center; gap:6px;">
<i aria-hidden="true" class="fas fa-sync-alt"></i>
<span class="method-title">TTA</span>
</h4>
</div>
<p class="method-desc" style="margin:0; font-size:13px; line-height:1.4;">
                                        Apply training data augmentations at test time.
                                    </p>
</div>
</button>
</div>
<figure class="methods-visual fragment fade-up method-visual" style="animation-delay:0.3s; margin:0;" data-zoomable="true">
<img alt="Uncertainty methods illustration" id="method-svg" loading="lazy" role="img" src="../ESTRO/metric2.svg" style="max-width:100%; height:480px; border-radius:8px; background: #ffffff; 
                                display:block; padding: 12px; box-sizing:border-box;"/>
<figcaption aria-live="polite" id="svg-caption" style="font-size:12px; color:#666; margin-top:8px;">
                                Click a method above to see its visualization
                            </figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="40" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 22.73%;"></div>
</div>
<div aria-label="Slide 4" class="slide-counter">4</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — UQ SOTA (≈2:00)</h3>
<section>
<h4>Presenter Script (≈2:00)</h4>
<p>Deep learning models make excellent predictions on average, but individual predictions have highly
                variable quality. Some segmentations might be 90% accurate while others are only 40%—you can't tell
                which is which by looking at the prediction alone. This variable quality is a critical problem for
                clinical deployment. The solution is uncertainty quantification: automatically estimate how reliable
                each prediction is. This allows us to: (1) flag low-quality predictions for manual review or correction,
                which helps us improve the model; and (2) confidently deploy high-confidence predictions without
                additional review, saving time. So how do we measure this reliability? Bayesian approaches use a simple
                but powerful idea: generate multiple predictions and measure their disagreement. When predictions
                disagree, the model is uncertain. When they agree, we can trust the result. Three mainstream methods
                implement this: Monte Carlo Dropout, Deep Ensembles, and Test-Time Augmentation. Each differs in cost
                and implementation, but all share the same core principle—more disagreement means more uncertainty.</p>
</section>
<section>
<h4>Backup: What is UQ?</h4>
<ul>
<li><strong>Goal:</strong> Quantify model confidence for each prediction.</li>
<li><strong>Idea:</strong> Instead of a binary mask, estimate probability/confidence distribution.</li>
<li><strong>Why medical:</strong> Safety (flag errors), efficiency (triage review), regulatory
                    compliance (EU AI Act).</li>
<li><strong>Application:</strong> Error painting—highlight uncertain regions for clinician review.</li>
</ul>
</section>
<section>
<h4>Backup: Methods</h4>
<ul>
<li><strong>MCDO:</strong> Keep dropout on at test time (T forward passes); uncertainty from stochastic
                    variation. Cost: N=20, M=21.</li>
<li><strong>Deep Ensembles:</strong> Train K independent models; uncertainty from ensemble disagreement.
                    Cost: N=10, M=11 (high memory).</li>
<li><strong>TTA:</strong> Augment inputs at test time (rotations, flips, etc.); uncertainty from
                    consensus. Cost: N=8, M=9.</li>
<li><strong>Common problem:</strong> All require multiple inferences, prohibitive in online adaptive
                    radiotherapy.</li>
</ul>
</section>
<section>
<h4>Backup: Limitations</h4>
<ul>
<li><strong>Patient-level triage:</strong> Clinicians ask "Is this patient safe?" not "Which pixels are
                    uncertain?" Current methods focus on pixel-level error painting.</li>
<li><strong>Poor patient-level calibration:</strong> Methods are well-calibrated on average (dataset
                    level) but fail on individual patients (some patients have high confidence with poor segmentation).
                </li>
<li><strong>Evaluation inadequate:</strong> Summary metrics (Spearman, AURC) don't define actionable
                    thresholds or safety guarantees.</li>
<li><strong>Regulatory gap:</strong> No framework to report quantified safety bounds required by EU AI
                    Act.</li>
</ul>
</section>
</aside>
</section>
<script>
    (function () {
        const root = document.querySelector('[data-element-id="slide4-tabs"]');
        if (!root) return;

        const tabs = Array.from(root.querySelectorAll('[role="tab"]'));
        const panels = Array.from(root.querySelectorAll('[role="tabpanel"]'));

        function selectTab(tab) {
            tabs.forEach(t => t.setAttribute('aria-selected', 'false'));
            panels.forEach(p => {
                p.setAttribute('aria-hidden', 'true');
                p.setAttribute('hidden', '');
            });

            tab.setAttribute('aria-selected', 'true');
            const panelId = tab.getAttribute('aria-controls');
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.setAttribute('aria-hidden', 'false');
                panel.removeAttribute('hidden');
            }
        }

        tabs.forEach(tab => {
            tab.addEventListener('click', () => selectTab(tab));
            tab.addEventListener('keydown', e => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    selectTab(tab);
                }
            });
        });
    })();

    /* changelog: rationale: Remove entropy and dice equations from inlined SVGs to avoid
       rendering sensitive equation overlays in tabs. source: slides/04.html (this script block) */

    // Helper: remove entropy / Dice equation text/groups from an inlined SVG
    function removeEntropyDice(svg) {
        if (!svg || !svg.querySelector) return;
        // Target formula-like tokens only to avoid removing graphical groups/classes
        const regex = /(?:H\(|Dice\(|U_dice|Bᵢ|Σ|𝟙|log₂|τ|⟨|⟩|\bentropy\b|\bDice\b)/i;

        try {
            // Remove only text/tspan/title/desc nodes that contain formula tokens.
            Array.from(svg.querySelectorAll('text, tspan, title, desc, foreignObject')).forEach(node => {
                const txt = (node.textContent || '').trim();
                if (txt && regex.test(txt)) node.remove();
            });

            // Do NOT remove <g> groups by id/class — many visuals use names like 'dice-viz' or 'entropy-viz'.
        } catch (e) {
            // best-effort: swallow parsing quirks
        }
    }

    // Inline external SVGs so we can style internal text (make it dark for readability)
    (function inlineExternalSVGs() {
        const svgImgSelector = '#method-svg, #slide4-bayes-img, #slide4-dice-img, #svg-container img, figure img';
        const imgs = Array.from(document.querySelectorAll(svgImgSelector));
        if (!imgs.length) return;

        imgs.forEach(img => {
            const src = img.getAttribute('src') || img.dataset?.src;
            if (!src || !/\.svg(\?|$)/i.test(src)) return;

            fetch(src, { cache: 'no-cache' }).then(r => r.text()).then(text => {
                const parser = new DOMParser();
                const doc = parser.parseFromString(text, 'image/svg+xml');
                const svg = doc.querySelector('svg');
                if (!svg) return;

                // Remove entropy / dice equations if present
                removeEntropyDice(svg);

                // Transfer useful attributes from the img to the inlined svg
                if (img.id) {
                    // preserve the original id so other scripts can still find the element
                    svg.id = img.id;
                    svg.dataset.inlined = 'true';
                }
                if (img.className) svg.classList.add(...img.className.split(' '));
                // Preserve presentational size hints
                if (img.getAttribute('width')) svg.setAttribute('width', img.getAttribute('width'));
                if (img.getAttribute('height')) svg.setAttribute('height', img.getAttribute('height'));
                if (img.style?.width) svg.style.width = img.style.width;
                if (img.style?.height) svg.style.height = img.style.height;

                // Accessibility: move alt => aria-label, keep role
                const alt = img.getAttribute('alt') || img.getAttribute('aria-label');
                if (alt) {
                    svg.setAttribute('role', 'img');
                    svg.setAttribute('aria-label', alt.trim());
                }

                // Ensure a white backdrop and subtle shadow container for SVGs
                svg.style.backgroundColor = '#ffffff';
                svg.style.borderRadius = '8px';
                svg.style.boxShadow = '0 10px 24px rgba(16, 40, 80, 0.09), 0 2px 6px rgba(16, 40, 80, 0.04)';
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.display = 'block';
                svg.style.padding = '12px';
                svg.style.boxSizing = 'border-box';
                svg.style.overflow = 'visible';
                // Fix viewBox to prevent left-side cropping: use xMidYMid instead of xMinYMin
                const viewBox = svg.getAttribute('viewBox');
                if (viewBox) {
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                }

                // Force internal text elements to a dark fill for readability
                try {
                    const textNodes = svg.querySelectorAll('text, tspan');
                    textNodes.forEach(t => {
                        t.setAttribute('fill', '#1a1a1a');
                        t.setAttribute('fill-opacity', '1');
                        // remove any white stroke/fill that would reduce contrast
                        t.removeAttribute('stroke');
                        t.removeAttribute('stroke-width');
                        t.style.color = '#1a1a1a';
                        t.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", sans-serif';
                    });
                    // Also ensure group elements don't have opacity masking
                    const groups = svg.querySelectorAll('g');
                    groups.forEach(g => {
                        if (g.style.opacity === '0' || g.getAttribute('opacity') === '0') {
                            g.style.opacity = '1';
                            g.setAttribute('opacity', '1');
                        }
                    });
                } catch (e) { /* ignore parsing quirks */ }

                // Replace the img in the DOM with the inlined svg
                img.replaceWith(svg);
            }).catch(() => {
                // failed to inline; leave the <img> as-is
            });
        });
    })();

    // Method button functionality
    (function () {
        const methodButtons = document.querySelectorAll('.method-button');

        // Note: don't early-return if the method SVG isn't present at load time; resolve it when needed.

        const methodDescriptions = {
            'mcdo': {
                src: '../ESTRO/mcdo_method.svg',
                alt: 'MCDO visualization showing dropout-enabled inference and varying predictions',
                caption: 'MCDO: Monte Carlo Dropout — Keep dropout enabled at test time and run multiple forward passes, creating an ensemble of stochastic predictions from a single model.'
            },
            'ensemble': {
                src: '../ESTRO/ensemble_method.svg',
                alt: 'Deep Ensembles visualization showing disagreement across independently trained models',
                caption: 'Deep Ensembles — Train several independent models from scratch with different random initializations. Disagreement between their predictions measures uncertainty.'
            },
            'tta': {
                src: '../ESTRO/tta_method.svg',
                alt: 'Test-time augmentation visualization showing variations across augmented inputs',
                caption: 'Test-Time Augmentation — Apply random transformations (rotations, flips, zoom) used in training at test time and process each augmented version with the same trained model. Predictions are mapped back to original input to measure uncertainty.'
            }
        };

        function activateMethod(method, btn) {
            // re-query the image and caption so function works even if they weren't present at load
            const svgEmbed = document.getElementById('method-svg');
            const svgCaption = document.getElementById('svg-caption');

            // Update active/pressed state
            methodButtons.forEach(b => {
                b.classList.remove('active');
                b.setAttribute('aria-pressed', 'false');
            });

            const activeBtn = btn || document.querySelector(`[data-method="${method}"]`);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.setAttribute('aria-pressed', 'true');
            }

            // Resolve source: prefer explicit data-svg on the button, otherwise fallback to mapping
            const srcFromButton = activeBtn?.dataset?.svg;
            const methodData = methodDescriptions[method] || {};
            const src = srcFromButton || methodData.src;

            if (src && svgEmbed) {
                const tag = (svgEmbed.tagName || svgEmbed.nodeName || '').toLowerCase();
                if (tag === 'img') {
                    // simple case: replace image src
                    svgEmbed.src = src;
                    if (!svgEmbed.style.height) svgEmbed.style.height = '420px';
                    svgEmbed.alt = methodData.alt || svgEmbed.alt || 'Visualization';
                } else if (tag === 'svg') {
                    // inlined svg: fetch new SVG and replace the node content
                    fetch(src, { cache: 'no-cache' }).then(r => r.text()).then(text => {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(text, 'image/svg+xml');
                        const newSvg = doc.querySelector('svg');
                        if (!newSvg) return;

                        // preserve id and classes
                        if (svgEmbed.id) newSvg.id = svgEmbed.id;
                        if (svgEmbed.classList && svgEmbed.classList.length) {
                            newSvg.classList.add(...Array.from(svgEmbed.classList));
                        }

                        // transfer inline sizing/style hints
                        if (svgEmbed.style?.width) newSvg.style.width = svgEmbed.style.width;
                        if (svgEmbed.style?.height) newSvg.style.height = svgEmbed.style.height;

                        // accessibility
                        const alt = methodData.alt || svgEmbed.getAttribute('aria-label') || svgEmbed.getAttribute('alt');
                        if (alt) {
                            newSvg.setAttribute('role', 'img');
                            newSvg.setAttribute('aria-label', alt);
                        }

                        // ensure same visual backdrop as before
                        newSvg.style.backgroundColor = '#ffffff';
                        newSvg.style.borderRadius = '8px';
                        newSvg.style.boxShadow = '0 10px 24px rgba(16, 40, 80, 0.09), 0 2px 6px rgba(16, 40, 80, 0.04)';
                        newSvg.style.width = '100%';
                        newSvg.style.height = 'auto';
                        newSvg.style.display = 'block';
                        newSvg.style.padding = '12px';
                        newSvg.style.boxSizing = 'border-box';
                        newSvg.style.overflow = 'visible';
                        // Fix viewBox to prevent left-side cropping
                        const viewBox = newSvg.getAttribute('viewBox');
                        if (viewBox) {
                            newSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                        }

                        // force internal text color dark
                        try {
                            const textNodes = newSvg.querySelectorAll('text, tspan');
                            textNodes.forEach(t => {
                                t.setAttribute('fill', '#1a1a1a');
                                t.setAttribute('fill-opacity', '1');
                                t.removeAttribute('stroke');
                                t.removeAttribute('stroke-width');
                                t.style.color = '#1a1a1a';
                                t.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", sans-serif';
                            });
                            // Ensure group elements are visible
                            const groups = newSvg.querySelectorAll('g');
                            groups.forEach(g => {
                                if (g.style.opacity === '0' || g.getAttribute('opacity') === '0') {
                                    g.style.opacity = '1';
                                    g.setAttribute('opacity', '1');
                                }
                            });
                        } catch (e) { }

                        // Remove entropy / dice equations if present in the fetched SVG
                        try { removeEntropyDice(newSvg); } catch (e) { }

                        svgEmbed.replaceWith(newSvg);
                    }).catch(() => { /* leave existing svg if fetch fails */ });
                }
            }

            if (svgCaption) {
                svgCaption.textContent = methodData.caption || '';
            }
        }

        methodButtons.forEach(button => {
            button.addEventListener('click', () => {
                const method = button.getAttribute('data-method');
                activateMethod(method, button);
            });

            button.addEventListener('keydown', e => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    const method = button.getAttribute('data-method');
                    activateMethod(method, button);
                }
            });
        });

        // Set a sensible default method on load so the Methods panel is not empty
        // (no-op if elements are not present)
        try { activateMethod('mcdo'); } catch (e) { /* ignore */ }

        // Cache-busting helper: ensure updated SVGs are fetched when file changed locally.
        (function () {
            const img = document.getElementById('slide4-dice-img');
            if (!img) return;
            const src = img.dataset?.src || img.getAttribute('src');
            // Try HEAD to get a stable last-modified fingerprint; fallback to Date.now()
            fetch(src, { method: 'HEAD', cache: 'no-cache' }).then(res => {
                const lm = res.headers.get('last-modified');
                const v = lm ? (new Date(lm)).getTime() : Date.now();
                img.src = src + '?v=' + v;
            }).catch(() => {
                img.src = src + '?v=' + Date.now();
            });
        })();

    })();
</script>

<section aria-roledescription="slide" class="slide-container" data-node-id="roadmap-node-transition" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div aria-label="Slide status" class="status-banner" style="margin-left: auto; display:flex; gap:8px; align-items:center;">
<span class="status-badge accepted" style="margin-right: 8px; font-size: 11px;">
<i aria-hidden="true" class="fas fa-check-circle"></i> Accepted - ESTRO 2026
            </span>
</div>
</div>
<div style="padding: 20px 28px;">
<div style="display:flex; align-items:flex-start; justify-content:space-between; gap:16px;">
<div style="flex:1;">
<h2 class="slide-title fragment fade-up" data-element-id="slide5-title">
<i aria-hidden="true" class="fas fa-flask-vial" style="color: #0066CC; margin-right: 12px;"></i>
                    Comparative Study of UQ methods for segmentation
                </h2>
<p class="slide-subtitle fragment fade-up" style="animation-delay: 0.1s; margin-top:4px; font-style: italic">
                    Can Input reconstruction predict segmentation error ?
                </p>
</div>
<div aria-label="Slide tabs" class="tablist" data-element-id="slide5-tablist" role="tablist">
<button aria-controls="slide5-panel-approach" aria-selected="false" class="tab" id="approach-toggle" role="tab"><i aria-hidden="true" class="fas fa-lightbulb"></i>Reconstruction-based UQ</button>
<button aria-controls="slide5-panel-study" aria-selected="true" class="tab active" id="study-toggle" role="tab"><i aria-hidden="true" class="fas fa-flask-vial"></i>Methods</button>
<button aria-controls="slide5-panel-results" aria-selected="false" class="tab" id="results-toggle" role="tab"><i aria-hidden="true" class="fas fa-chart-bar"></i>Results</button>
</div>
</div>
<div class="tabbed-pane" data-element-id="slide5-tabs">
<div class="tab-panels" style="margin-top: -12px;">
<div aria-hidden="true" class="tab-panel" data-element-id="slide5-panel-approach" hidden="" id="slide5-panel-approach" role="tabpanel">
<div style="margin-top: 0px; display: center; align-items:center">
<div style="display:grid; grid-template-columns: 1fr 1fr; gap: 18px; align-items: start; margin-left:5%; margin-right:5%;">
<div class="fragment fade-up" style="animation-delay: 0.2s; padding:14px; background:#E8F5E9; border-radius:8px; border-left:4px solid #27AE60;">
<p style="font-size:13px; color:#2E7D32; margin:0;"><strong>Huet et al. for dose
                                        prediction:</strong></p>
<br/>
<p style="font-size:13px; color:#2E7D32; margin:0;">add a
                                    branch to a UNET to reconstruct the input, use the MSE as error surrogate</p>
</div>
<div class="fragment fade-up" style="animation-delay: 0.4s; padding: 14px; 
                                            background: linear-gradient(135deg, #FFF3E6, #FFE8CC); border-radius: 8px; 
                                            border-left: 4px solid #E67E22;">
<p style="margin:0; font-size:13px; color:#C85A17;"><i aria-hidden="true" class="fas fa-bookmark" style="margin-right:6px;"></i><strong>Proposed
                                        adaptation:</strong></p><br/>
<p style="margin:0; font-size:13px; color:#C85A17;">Segment on the reconstruction, use
                                    Dice
                                    between the two
                                    predictions as the uncertainty</p>
</div>
</div>
<figure class="fragment fade-up method-visual" style="width:60%; height:480px; border-radius:8px; object-position:center; margin-top:32px; margin-left:20%; margin-right:auto;" data-zoomable="true">
<img alt="Reconstruction-based Dice metric used for low-cost UQ (ESTRO)" loading="lazy" src="../ESTRO/recon_metric.svg" style="max-height:100%; border-radius:8px;display: block;"/>
<figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
</div>
</div>
<div aria-hidden="false" class="tab-panel" data-element-id="slide5-panel-study" id="slide5-panel-study" role="tabpanel">
<div style="margin-top: 24px; display: grid; grid-template-columns: 0.7fr 1fr; gap: 28px; align-items:center;">
<!-- changelog: rationale: split datasets and methods into two separate cards for visual parity; source: slides/05.html lines 46-72 -->
<div style="align-items:start; display:flex; flex-direction:column; gap:14px;">
<div class="fragment fade-up" style="animation-delay: 0.2s; padding:14px; background: rgba(255,255,255,0.96); border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.08);">
<h3 style="font-weight:700; color:#0066CC; margin-top:0; margin-bottom:10px;"><i aria-hidden="true" class="fas fa-database" style="margin-right:8px;"></i>Datasets
                                </h3>
<p style="font-size:13px; color:#555; margin:0 0 12px 0;">Four datasets evaluated across
                                    all
                                    methods:</p>
<ul style="margin: 0 0 14px 0; padding-left: 20px; font-size: 13px; color: #333; line-height: 1.6;">
<li><strong>BraTS</strong> — brain tumor MRI segmentation</li>
<li><strong>Pancreas</strong> — abdominal CT pancreas segmentation</li>
<li><strong>LUNG</strong> — thoracic CT lung segmentation</li>
<li><strong>ABDO1k</strong> — large abdominal multi-organ cohort</li>
</ul>
</div>
<!-- Methods card (separate) -->
<div class="fragment fade-up" style="animation-delay: 0.22s; padding:14px; background: rgba(255,255,255,0.96); 
                                border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.08); margin-top:16px">
<div aria-label="Methods compared" class="methods-list" data-element-id="slide5-methods-list" role="group" style="margin-top:0;">
<h4 style="margin:0 0 6px; color:#0066CC; font-size:14px;">UQ Methods Compared</h4>
<ul role="list" style="margin:0; padding-left:18px; font-size:13px; color:#333; line-height:1.6;">
<li>MCDO</li>
<li>Ensembles</li>
<li>TTA</li>
<li>Reconstruction-based</li>
</ul>
</div>
</div>
<!-- changelog: rationale: add brief literature note about dataset coverage in UQ papers; source: slides/05.html near Methods card; requires_human_approval: true -->
<div aria-label="Literature note" class="fragment fade-up" role="note" style="animation-delay: 0.24s; padding:12px; background: linear-gradient(180deg,#FFF9E6,#FFF3CC); border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.06); margin-top:12px;">
<p style="margin:0; font-size:13px; color:#333;"><strong>Note:</strong>
                                    Most UQ papers in tumor segmentation report results on only one or two datasets.</p>
</div>
</div>
<div class="fragment fade-up" style="animation-delay:0.3s;">
<div aria-label="Dataset samples gallery" class="datasets-gallery" role="region" style="margin-top:6px;" tabindex="0">
<div class="datasets-main" style="position:relative; display:flex; align-items:center; justify-content:center;max-height:6400px;">
<button aria-label="Previous dataset" class="datasets-prev" style="background:none;border:none;cursor:pointer;font-size:22px;line-height:1;padding:6px 10px;" role="button" tabindex="0">‹</button>
<div style="text-align:center;">
<figure style="width:100%; max-height:480px; aspect-ratio: 6 / 3; display:flex; 
                                            align-items:center; justify-content:center; overflow:hidden; border-radius:8px;" class="method-visual" data-zoomable="true">
<img id="slide5-datasets-img" loading="lazy" src="../DATASET/BRATS.png" style="width:100%; max-height:100%; display:block; object-fit:contain;"/>
<figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
<figure aria-label="ABDO1k samples" class="datasets-abdo-container method-visual" id="slide5-datasets-abdo-container" role="group" style="width:100%; max-height:480px; aspect-ratio: 6 / 3;
                                            align-items:center; justify-content:center; overflow:hidden; border-radius:8px;
                                            display:none;" data-zoomable="true">
<!-- changelog: rationale: remove fixed inline heights so ABDO gallery images match the main
                                                 gallery container height and maintain visual parity with single images; source: slides/05.html HTML abdo container -->
<img alt="ABDO1 sample" class="datasets-abdo-img" loading="lazy" src="../DATASET/ABDO1.png" style="object-fit:contain;"/>
<img alt="ABDO2 sample" class="datasets-abdo-img" loading="lazy" src="../DATASET/ABDO2.gif" style="object-fit:contain;"/>
<figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
<p aria-live="polite" class="panel-caption" id="slide5-datasets-caption" style="margin-top:8px;">
                                            BraTS — brain tumor MRI example</p>
</div>
<button aria-label="Next dataset" class="datasets-next" style="background:none;border:none;cursor:pointer;font-size:22px;line-height:1;padding:6px 10px;" role="button" tabindex="0">›</button>
</div>
<div class="datasets-thumbs" role="list" style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
<button aria-label="Show BraTS dataset" aria-pressed="true" class="datasets-thumb" data-caption="BraTS — brain tumor 4 modality MRI" data-src="../DATASET/BRATS.png" data-type="single" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="BraTS thumbnail" loading="lazy" src="../DATASET/BRATS.png" style="width:80px;height:40px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show Pancreas dataset" aria-pressed="false" class="datasets-thumb" data-caption="Pancreas — abdominal CT with pancreatic tumors" data-src="../DATASET/pancreas.png" data-type="single" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="Pancreas thumbnail" loading="lazy" src="../DATASET/pancreas.png" style="width:80px;height:40px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show LUNG dataset" aria-pressed="false" class="datasets-thumb" data-caption="LUNG — thoracic CT with non-small cell lung tumors" data-src="../DATASET/LUNG.jpg" data-type="single" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="LUNG thumbnail" loading="lazy" src="../DATASET/LUNG.jpg" style="width:80px;height:40px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show ABDO1k dataset" aria-pressed="false" class="datasets-thumb" data-caption="ABDO1k — large abdominal multi-organ cohort" data-src="../DATASET/ABDO1.png" data-type="double" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="ABDO1k thumbnail" loading="lazy" src="../DATASET/ABDO1.png" style="width:80px;height:40px;object-fit:cover;border-radius:4px;"/>
</button>
</div>
</div>
</div>
</div>
</div>
<div aria-hidden="true" class="tab-panel" data-element-id="slide5-panel-results" hidden="" id="slide5-panel-results" role="tabpanel">
<div style="margin-top: 20px; margin-left: -20px; margin-right: -20px;">
<div style="padding: 0 20px; align-items:center">
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 18px; margin-top: 18px;">
<div class="fragment fade-up" style="animation-delay: 0.3s; padding: 14px; background: linear-gradient(135deg, #E8F5E9, #C8E6C9); border-radius: 8px; border-left: 4px solid #27AE60;">
<p style="margin: 0; font-size: 13px; color: #2E7D32;">
<i aria-hidden="true" class="fas fa-check-circle" style="margin-right: 8px;"></i>
<strong>Metric Validation:</strong> Reconstruction-based UQ competitive with
                                        ensembles
                                    </p>
</div>
<div class="fragment fade-up" style="animation-delay: 0.4s; padding: 14px; background: linear-gradient(135deg, #E8F5E9, #C8E6C9); border-radius: 8px; border-left: 4px solid #27AE60;">
<p style="margin: 0; font-size: 13px; color: #2E7D32;">
<i aria-hidden="true" class="fas fa-zap" style="margin-right: 8px;"></i>
<strong>Cost Achievement:</strong> 4-10× lower computational overhead validated
                                    </p>
</div>
</div>
<div style="text-align:center; margin-bottom:0; margin-top:22px; padding: 0; align-items: center">
<figure style="width:75%; max-height:640px; border-radius:8px; margin: 0 auto;" class="method-visual" data-zoomable="true">
<img alt="Complete results showing Spearman correlation, AURC (Area Under Ranking Curve), and cost metrics across MCDO, Ensembles, TTA, and Reconstruction-based UQ methods on multiple datasets" data-element-="" id="slide5-img-results" loading="lazy" src="../ESANN/sota.png" style="width:100%; height:100%; display:block; margin: 0 auto;"/>
<figcaption style="font-size:12px; color:#666; margin-top:8px;">ESTRO accepted:
                                        reconstruction-based UQ is competitive on Spearman rho and AURC across datasets
                                        at
                                        10x lower computational cost
                                        <button aria-label="Explain AURC metric" class="explain-btn" id="slide5-aurc-explain-btn" style="background:#3790e9; color:white; border:none; border-radius:6px; 
                                            padding:6px 10px; cursor:pointer; font-size:12px; display:inline-flex; 
                                            align-items:center; justify-content:center; gap:8px; 
                                            box-shadow:0 2px 8px rgba(0,102,204,0.3); transition:all 150ms ease; 
                                            margin-left:12px; vertical-align:middle; position:relative;" title="Click to see AURC explanation" role="button" tabindex="0">
                                            AURC <i aria-hidden="true" class="fas fa-question-circle" style="font-size:14px"></i>
</button>
</figcaption>
</figure>
</div>
<!-- AURC Explanation Modal -->
<div class="aurc-modal" id="slide5-aurc-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:9999; align-items:center; justify-content:center;">
<div class="modal-content" style="background:white; border-radius:8px; padding:24px; max-width:600px; max-height:80vh; overflow-y:auto; box-shadow:0 8px 32px rgba(0,0,0,0.3); position:relative;">
<button aria-label="Close AURC explanation" class="modal-close" id="slide5-modal-close" style="position:absolute; top:12px; right:12px; background:none; border:none; font-size:24px; cursor:pointer; color:#666; padding:4px 8px;" role="button" tabindex="0">
<i aria-hidden="true" class="fas fa-times"></i>
</button>
<h3 style="color:#0066CC; margin-top:0; margin-bottom:16px; font-weight:700;">What
                                        is
                                        AURC?</h3>
<figure style="margin:0 auto 16px auto; text-align:center;" class="method-visual" data-zoomable="true">
<img alt="AURC (Area Under Ranking Curve) explanation diagram" data-element-id="slide5-aurc-figure" data-zoomable="true" id="slide5-aurc-figure" loading="lazy" src="../ESTRO/fd_figure1.svg" style="max-width:100%; height:auto; border-radius:6px; cursor:zoom-in; margin: 0 auto; display: block;"/>
<figcaption style="font-size:14px; color:#666; margin-top:8px;">Area Under
                                            Ranking
                                            Curve (AURC): integrates average error through all decision thresholds.
                                        </figcaption>
</figure>
<div style="font-size:13px; color:#333; line-height:1.6;">
<p style="margin:0 0 6px 0;">Lower AURC = low risk even with poor decision
                                            thresholds.</p>
</div>
</div>
</div>
<div class="fragment fade-up" style="animation-delay: 0.5s; margin-top: 24px; padding: 14px; background: linear-gradient(135deg, #FFF3E6, #FFE8CC); border-radius: 8px; border-left: 4px solid #E67E22;">
<p style="margin: 0; color: #C85A17; font-size: 13px;">
<i aria-hidden="true" class="fas fa-exclamation-circle" style="margin-right: 6px;"></i><strong>Key Observation:</strong>Spearman or AURC scores
                                    mask
                                    per-case failures.
                                    Summary metrics cannot provide safety guarantees.
                                </p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — Comparative Study of Reconstruction-Based UQ</h3>
<section>
<h4>Multi-Method Study (Tab 1) — Presenter Script (≈0:25)</h4>
<p><strong>Rarity:</strong> Most papers compare 1–2 methods on 1 dataset. We systematically compared 4 UQ
                methods (MCDO, Ensembles, TTA, Reconstruction) across 4 datasets—a comprehensive evaluation rarely seen
                in literature.</p>
<p><strong>Methods:</strong> MCDO (dropout-based), Ensembles (model averaging), TTA (test-time
                augmentation), Reconstruction-based (novel low-cost approach).</p>
<p><strong>Metrics:</strong> Standard evaluation uses Spearman correlation, Dice, and DAUC to rank and
                compare methods.</p>
</section>
<section>
<h4>Reconstruction-based UQ (Tab 2) — Presenter Script (≈0:30)</h4>
<p><strong>Prior work:</strong> Marjorie's earlier work showed that reconstruction quality (via autoencoder)
                correlates with segmentation uncertainty. We adapted her reconstruction-based approach to use Dice-based
                comparison—enabling systematic benchmarking against other UQ methods.</p>
<p><strong>Pipeline:</strong> Input → Reconstruct (encode-decode) → Re-segment reconstructed image → Compare
                segmentations via Surface Dice difference. This difference becomes the uncertainty signal.</p>
<p><strong>Why Dice?</strong> Surface Dice is clinically relevant (captures organ boundary shifts), enables
                fair comparison, and is computationally cheap (N=2, M=1—10× lower cost than MCDO).</p>
<p><strong>ESTRO contribution:</strong> This methodological adaptation was the subject of the ESTRO 2026
                abstract.</p>
</section>
<section>
<h4>Results (Tab 3) — Presenter Script (≈0:35)</h4>
<p><strong>Finding:</strong> The complete results figure shows Reconstruction-based UQ achieves competitive
                performance across both Spearman correlation and AURC (Area Under the Ranking Curve) metrics, while
                costing 10× less computationally (N=2, M=1 vs. N=8–20).</p>
<p><strong>What's AURC?</strong> AURC measures how well the uncertainty estimate ranks predictions by
                error—a summary of the method's ranking quality. Both Spearman ρ and AURC appear strong for our method
                across datasets.</p>
<p><strong>Critical observation:</strong> However, here's the catch—high AURC and good correlation do not
                guarantee clinical safety or practical outcomes. Slide 06 will show this visually: when you plot Dice
                score vs. our uncertainty estimate, you see that high-Dice cases (where our model performed well)
                cluster tightly, but low-Dice cases scatter widely. The correlation metrics are biased toward good model
                performance; they don't capture worst-case scenarios clinicians worry about.</p>
<p><strong>Bridge to Slide 06:</strong> This observation motivates the next slide's central question: if
                standard metrics like AURC are insufficient for clinical deployment, what evaluation paradigm matches
                radiotherapy's safety requirements (worst-case scenario mindset)? The answer is safety-constrained
                evaluation with explicit decision thresholds U*.</p>
</section>
<section>
<h4>Overall Narrative Arc</h4>
<p>Slide 04 established the UQ landscape and cost problem. Slide 05 shows how we systematically studied
                reconstruction-based approaches (methodological novelty: multi-method, multi-dataset comparison). Slide
                06 critiques the evaluation approach and proposes a safety-centric alternative.</p>
</section>
</aside>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="50" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 27.27%;"></div>
</div>
<div aria-label="Slide 5" class="slide-counter">5</div>
</section>
<script>
    (function () {
        const root = document.querySelector('[data-node-id="roadmap-node-transition"]');
        if (!root) return;

        const studyBtn = root.querySelector('#study-toggle');
        const approachBtn = root.querySelector('#approach-toggle');
        const resultsBtn = root.querySelector('#results-toggle');
        const panelStudy = root.querySelector('#slide5-panel-study');
        const panelApproach = root.querySelector('#slide5-panel-approach');
        const panelResults = root.querySelector('#slide5-panel-results');

        if (!studyBtn || !approachBtn || !resultsBtn || !panelStudy || !panelApproach || !panelResults) {
            console.warn('Slide 5 multi-tab: missing elements');
            return;
        }

        // Slide 5 now relies on the global initializer for wiring tabs/toggles.
        // We keep a small augmentation to announce the active panel to assistive technologies.
        (function () {
            const root = document.querySelector('[data-node-id="roadmap-node-transition"]');
            if (!root) return;
            const panels = Array.from(root.querySelectorAll('#slide5-panel-study, #slide5-panel-approach, #slide5-panel-results'));
            const live = root.querySelector('[aria-live]') || (function () { const d = document.createElement('div'); d.className = 'visually-hidden'; d.setAttribute('aria-live', 'polite'); root.appendChild(d); return d; })();

            function updateLive() {
                const active = panels.find(p => !p.hidden && p.getAttribute('aria-hidden') !== 'true') || panels[0];
                const caption = active ? (active.querySelector('.panel-caption') || active.querySelector('h3') || active) : null;
                live.textContent = caption ? (caption.textContent || '').trim() : '';
            }

            updateLive();
            const obs = new MutationObserver(updateLive);
            panels.forEach(p => obs.observe(p, { attributes: true, attributeFilter: ['hidden', 'aria-hidden'] }));
        })();

        // Provide robust local fallbacks for the page-level helpers if they are not present yet
        function animateSwitch(panel) {
            if (typeof window.animateSwitch === 'function') { window.animateSwitch(panel); return; }
            // Simple non-animated switch: show target panel and hide others
            [panelStudy, panelApproach, panelResults].forEach(p => {
                const show = (p === panel);
                p.hidden = !show;
                p.setAttribute('aria-hidden', show ? 'false' : 'true');
            });
            setButtonStates();
        }

        function setButtonStates() {
            const buttons = [studyBtn, approachBtn, resultsBtn];
            buttons.forEach(btn => {
                const panel = root.querySelector(btn.getAttribute('aria-controls'));
                const active = panel && panel.getAttribute('aria-hidden') !== 'true';
                btn.classList.toggle('active', active);
                btn.setAttribute('aria-selected', active ? 'true' : 'false');
            });
        }
        studyBtn.addEventListener('click', () => animateSwitch(panelStudy));
        studyBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); studyBtn.click(); } });
        approachBtn.addEventListener('click', () => animateSwitch(panelApproach));
        approachBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); approachBtn.click(); } });
        resultsBtn.addEventListener('click', () => animateSwitch(panelResults));
        resultsBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); resultsBtn.click(); } });

        // Initialize states
        setButtonStates();

        // Focus management: move focus to active panel heading on tab switch
        function manageFocus(panel) {
            const heading = panel.querySelector('h3, h4');
            if (heading) {
                heading.setAttribute('tabindex', '-1');
                heading.focus();
            }
        }

        studyBtn.addEventListener('click', () => { animateSwitch(panelStudy); manageFocus(panelStudy); });
        approachBtn.addEventListener('click', () => { animateSwitch(panelApproach); manageFocus(panelApproach); });
        resultsBtn.addEventListener('click', () => { animateSwitch(panelResults); manageFocus(panelResults); });
    })();

    // Datasets gallery: thumbnails, prev/next, keyboard navigation
    (function initDatasetsGallery() {
        const panel = document.querySelector('#slide5-panel-study');
        if (!panel) return;
        const gallery = panel.querySelector('.datasets-gallery');
        if (!gallery) return;
        const main = gallery.querySelector('#slide5-datasets-img');
        const figure = gallery.querySelector('figure');
        const caption = gallery.querySelector('#slide5-datasets-caption');
        const thumbs = Array.from(gallery.querySelectorAll('.datasets-thumb'));
        const prev = gallery.querySelector('.datasets-prev');
        const next = gallery.querySelector('.datasets-next');
        let index = 0;
        const abdoContainer = gallery.querySelector('#slide5-datasets-abdo-container');
        const update = i => {
            const btn = thumbs[i];
            const src = btn.getAttribute('data-src');
            const cap = btn.getAttribute('data-caption');
            const type = btn.getAttribute('data-type');
            if (type === 'double') {
                // Hide the figure (which has an aspect-ratio) so it doesn't reserve vertical space
                if (figure) figure.style.display = 'none';
                if (abdoContainer) {
                    abdoContainer.style.display = 'flex';
                    abdoContainer.setAttribute('aria-hidden', 'false');
                }
            } else {
                // Show single image (restore figure) and hide the ABDO container
                if (figure) figure.style.display = '';
                if (abdoContainer) {
                    abdoContainer.style.display = 'none';
                    abdoContainer.setAttribute('aria-hidden', 'true');
                }
                main.src = src;
                main.alt = btn.querySelector('img').alt;
                main.style.display = 'block';
            }

            caption.textContent = cap;
            thumbs.forEach((t, idx) => t.setAttribute('aria-pressed', idx === i ? 'true' : 'false'));
            index = i;
        };
        thumbs.forEach((t, i) => {
            t.addEventListener('click', () => update(i));
            t.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); update(i); } });
        });
        prev && prev.addEventListener('click', () => update((index - 1 + thumbs.length) % thumbs.length));
        next && next.addEventListener('click', () => update((index + 1) % thumbs.length));
        gallery.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') prev && prev.click();
            if (e.key === 'ArrowRight') next && next.click();
        });
        // initialize
        // Ensure ABOD container has correct initial aria state
        if (abdoContainer) abdoContainer.setAttribute('aria-hidden', 'true');
        if (figure) figure.style.display = '';
        update(0);
    })();

    // AURC explanation modal functionality
    (function initAURCModal() {
        const modal = document.querySelector('#slide5-aurc-modal');
        const btn = document.querySelector('#slide5-aurc-explain-btn');
        const closeBtn = document.querySelector('#slide5-modal-close');
        const img = document.querySelector('#slide5-aurc-figure');

        if (!modal || !btn || !closeBtn || !img) return;

        function openModal() {
            modal.classList.add('show');
            modal.style.display = 'flex';
            closeBtn.focus();
        }

        function closeModal() {
            modal.classList.remove('show');
            modal.style.display = 'none';
            btn.focus();
        }

        btn.addEventListener('click', openModal);
        btn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openModal(); } });

        closeBtn.addEventListener('click', closeModal);
        closeBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); closeModal(); } });

        // Close modal when clicking outside
        modal.addEventListener('click', e => {
            if (e.target === modal) closeModal();
        });

        // ESC key to close
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape' && modal.classList.contains('show')) closeModal();
        });

        // Zoom functionality for the AURC figure
        if (img.getAttribute('data-zoomable') === 'true') {
            img.addEventListener('click', e => {
                e.stopPropagation();
                img.classList.toggle('zoomed');
                img.style.cursor = img.classList.contains('zoomed') ? 'zoom-out' : 'zoom-in';
            });
        }
    })();
</script>

<section aria-roledescription="slide" class="slide-container" data-node-id="esann-eval" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div aria-label="Slide status" class="status-banner" style="margin-left: auto; display:flex; gap:8px; align-items:center;">
<span class="status-badge accepted" style="margin-right: 8px; font-size: 11px;">
<i aria-hidden="true" class="fas fa-check-circle"></i> Accepted - ESANN 2026
            </span>
</div>
</div>
<div style="padding: 20px 28px; display:flex; flex-direction:column; height:100%;">
<div style="display:flex; align-items:flex-start; justify-content:space-between; gap:16px;">
<div style="flex:1;">
<h2 class="slide-title fragment fade-up" data-element-id="slide6-title">
<i aria-hidden="true" class="fas fa-balance-scale" style="color: #0066CC; margin-right: 12px;"></i>
                    Meaningful evaluation of uncertainty-aware segmentation workflows
                </h2>
<p class="slide-subtitle fragment fade-up" style="animation-delay: 0.1s; margin-top:4px;">
                    From summary metrics to safety-constrained guarantees
                </p>
</div>
<div aria-label="Slide tabs" class="tablist" role="tablist">
<button aria-controls="slide6-panel-intro" aria-selected="true" class="tab active" id="intro-toggle" role="tab"><i aria-hidden="true" class="fas fa-info-circle"></i>Intro</button>
<button aria-controls="slide6-panel-methods" aria-selected="false" class="tab" id="methods-toggle" role="tab"><i aria-hidden="true" class="fas fa-flask"></i>Methods</button>
<button aria-controls="slide6-panel-results" aria-selected="false" class="tab" id="results-toggle" role="tab"><i aria-hidden="true" class="fas fa-chart-line"></i>Results</button>
</div>
</div>
<div class="tabbed-pane" data-element-id="slide6-tabs" style="height:100%;">
<div class="tab-panels">
<!-- INTRO -->
<div aria-hidden="false" class="tab-panel" data-element-id="slide6-panel-intro" id="slide6-panel-intro" role="tabpanel">
<div class="intro-grid" style="margin-top: 12px; display:grid; grid-template-columns:0.6fr 1.4fr; gap:20px; align-items:start; height:100%;">
<!-- LEFT: KEY TAKEAWAYS -->
<div style="display:flex; flex-direction:column ; gap:16px; align-items: start; margin-top:56px">
<!-- Takeaway 1 -->
<div class="fragment fade-up" style="animation-delay: 0.3s;">
<div style="padding:12px; background:#FFF9F0; border-radius:8px; border-left:4px solid #E67E22;">
<p style="font-size:16px; color:#333; margin:0 0 4px 0;"><strong><i aria-hidden="true" class="fas fa-exclamation-circle" style="color:#E67E22; margin-right:6px;"></i>The
                                            Problem</strong></p>
<p style="font-size:13px; color:#555; margin:0;">High correlation ≠ clinical safety.
                                        Low Dice cases scatter widely, biasing metrics toward overconfidence.</p>
</div>
</div>
<!-- Takeaway 2 -->
<div class="fragment fade-up" style="animation-delay: 0.3s; width:120%;">
<div style="padding:12px; background:#f0f8ff; border-radius:8px; border-left:4px solid #0066CC;">
<p style="font-size:16px; color:#333; margin:0 0 4px 0;"><strong><i aria-hidden="true" class="fas fa-lightbulb" style="color:#0066CC; margin-right:6px;"></i>The Solution</strong></p>
<p style="font-size:13px; color:#555; margin:0;">Find decision threshold C* to
                                        maximize automation while guaranteeing safety
                                        compliance</p>
</div>
</div>
<!-- FORMULAS: risk & gain (added for clarity) -->
<div aria-label="Risk and Gain formulas" class="slide-card fragment fade-up" data-element-id="slide6-formulas" style="animation-delay:0.15s; width:120%; background:#FFFFFF; border-left:4px solid #8A8A8A; padding:12px; border-radius:6px; margin-bottom:10px;">
<p style="font-size:12px; color:#555; margin:0 0 6px 0;"><strong>Risk</strong> r(t) =
                                    P(Dice
                                    &lt; Q, C ≥ t) — probability an accepted case has quality below threshold Q.</p>
</div>
<!-- FORMULAS: risk & gain (added for clarity) -->
<div aria-label="Risk and Gain formulas" class="slide-card fragment fade-up" data-element-id="slide6-formulas" style="animation-delay:0.15s; width:120%; background:#FFFFFF; border-left:4px solid #8A8A8A; padding:12px; border-radius:6px; margin-bottom:10px;">
<p style="font-size:12px; color:#555; margin:0 0 6px 0;"><strong>Gain</strong> G(t) =
                                    P(Dice ≥ Q, C ≥ t) — fraction of cases automated at threshold t.</p>
</div>
</div>
<!-- RIGHT: IMAGE -->
<div style="height:560px!important; width:100%; overflow:hidden;">
<iframe aria-describedby="slide6-img-scatter-dice-confidence-caption" data-element-id="slide6-img-scatter-dice-confidence" data-src="../ESANN/interactive_scatter_abdo1k.html?mode=intro" style="width:100%; height:560px; border:none; display:block;" title="Dice vs Confidence interactive scatter plot"></iframe>
</div>
</div>
</div>
<!-- METHODS -->
<div aria-hidden="true" class="tab-panel" data-element-id="slide6-panel-methods" hidden="" id="slide6-panel-methods" role="tabpanel">
<div style="margin-top: 12px; display:grid; grid-template-columns:1.4fr 0.6fr; gap:18px;">
<!-- LEFT: INTERACTIVE VISUALIZATION -->
<div style="height:520px!important; overflow:hidden; width:100%;">
<iframe aria-describedby="slide6-img-scatter-dice-confidence-caption" data-element-id="slide6-img-scatter-dice-confidence" data-src="../ESANN/interactive_scatter_abdo1k.html?mode=methods" style="width:100%; height:100%; border:none; display:block;" title="Dice vs Confidence interactive scatter plot"></iframe>
</div>
<!-- RIGHT: VISUAL FLOW STEPS -->
<div class="fragment fade-up" style="animation-delay:0.2s; align-items: center; margin-top:24px;">
<div style="display:flex; flex-direction:column; gap:12px;">
<!-- Step 1 -->
<div class="method-step variant-blue" data-step="1" style="animation-delay: 0.2s;">
<div class="inner">
<div class="badge">1</div>
<div class="content">
<div style="font-size:13px; font-weight:700; color:#3b82c4;">Define
                                                Constraints</div>
<div style="font-size:13px; color:#555; margin-top:1px;">Quality threshold
                                                and maximum tolerable error rate R</div>
</div>
</div>
</div>
<!-- Arrow -->
<div style="text-align:center; color:#999; font-size:20px; margin:-6px 0;">↓</div>
<!-- Step 2 -->
<div class="method-step align-right variant-green" data-step="2" style="animation-delay: 0.2s;">
<div class="inner">
<div class="badge">2</div>
<div class="content">
<div style="font-size:13px; font-weight:700; color:#2f855a;">Find
                                                corresponding decision threshold U*</div>
<div style="font-size:13px; color:#555; margin-top:1px;">satisfying risk
                                                ≤ R</div>
</div>
</div>
</div>
<!-- Arrow -->
<div style="text-align:center; color:#999; font-size:20px; margin:-6px 0;">↓</div>
<!-- Step 3 -->
<div class="method-step variant-amber" data-step="3" style="animation-delay: 0.2s;">
<div class="inner">
<div class="badge">3</div>
<div class="content">
<div style="font-size:13px; font-weight:700; color:#b36a00;">Statistical
                                                guarantees</div>
<div style="font-size:13px; color:#555; margin-top:1px;">95% confidence
                                                low bound on automation gain</div>
</div>
</div>
</div>
<!-- Arrow -->
<div style="text-align:center; color:#999; font-size:20px; margin:-6px 0;">↓</div>
<!-- Step 4 -->
<div class="method-step align-right variant-purple" data-step="4" style="animation-delay: 0.2s;">
<div class="inner">
<div class="badge">4</div>
<div class="content">
<div style="font-size:13px; font-weight:700; color:#6b21a8;">Report
                                                Guarantees</div>
<div aria-label="Paper quote" data-requires-approval="true" style="font-size:13px; color:#555; margin-top:1px;">95% confidence
                                                that 27% of patients will have Dice ≥ 0.7, with ≤5% below 0.7;
                                                remaining 68% are manually checked</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<!-- RESULTS -->
<div aria-hidden="true" class="tab-panel" data-element-id="slide6-panel-results" hidden="" id="slide6-panel-results" role="tabpanel">
<div style="margin-top:0px; display:grid; grid-template-columns:1.4fr 1fr; gap:12px; align-items:center;">
<figure class="fragment fade-up method-visual" style="margin:0;" data-zoomable="true">
<img alt="Results: automation gains per dataset and method (safety constraints applied)" data-element-id="slide6-img-results" loading="lazy" src="../ESANN/results.png" style="max-width:100%; height:480px; border-radius:8px;"/>
<figcaption style="font-size:12px; color:#666; text-align:center; margin-top:8px;">
                                Automation gain for error rate R ≤ 0.03, Q=0.7 (left), Q=0.8 (right)</figcaption>
</figure>
<div>
<div class="slide-card fragment fade-up" style="animation-delay:0.3s; background:linear-gradient(135deg, #F0F7FF 0%, #E8F3FF 100%); border-left:4px solid #0066CC; padding:16px; border-radius:8px;">
<h3 style="font-size:14px; font-weight:700; color:#0066CC; margin-bottom:12px; display:flex; align-items:center; gap:8px;">
<i aria-hidden="true" class="fas fa-star" style="color:#FFB800;"></i>Key findings
                                </h3>
<ul style="font-size:12px; color:#333; line-height:1.6; margin-left:12px; padding:0; list-style:none;">
<li style="margin-bottom:12px; display:flex; align-items:flex-start; gap:10px;">
<span style="color:#E67E22; font-weight:bold; flex-shrink:0; margin-top:2px;">✓</span>
<span>Rank metrics ≠ deployment safety</span>
</li>
<li style="margin-bottom:10px; display:flex; align-items:flex-start; gap:10px;">
<span style="color:#27AE60; font-weight:bold; flex-shrink:0; margin-top:2px;">✓</span>
<span>Results are dataset-dependent</span>
</li>
<li style="display:flex; align-items:flex-start; gap:10px;">
<span style="color:#0066CC; font-weight:bold; flex-shrink:0; margin-top:2px;">✓</span>
<span>Report CI for guarantees</span>
</li>
</ul>
</div>
<!-- changelog: rationale: Add card describing ability to measure impact of overconfident cases on reliability; source: slides/06.html (left column takeaways) -->
<div class="slide-card fragment fade-up" style="animation-delay: 0.5s; margin-top:16px;">
<div aria-label="Measure overconfidence impact" data-element-id="slide6-card-overconfidence-impact" style="padding:12px; background:#FFF4F8; border-radius:8px; border-left:4px solid #A569BD;">
<p style="font-size:14px; color:#333; margin:0 0 4px 0;"><i aria-hidden="true" class="fas fa-bullseye" style="color:#A569BD; margin-right:6px;"></i>
                                        Directly measures how much overconfident predictions degrade model reliability,
                                        enabling
                                        benefit-to-risk trade-offs for calibration and model selection.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>

<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — Evaluation (tabbed)</h3>
<section>
<h4>Intro (Intro tab) — Presenter Script (≈0:50)</h4>
<p><strong>Opening:</strong> Slide 05 showed that reconstruction-based UQ achieves competitive Spearman
                correlation and AURC (Area Under Ranking Curve) metrics compared to ensemble methods. Sounds promising,
                right? But look at this scatter plot—Dice score vs. our confidence estimate.</p>
<p><strong>What you see:</strong> High Dice cases (where our model performed well) cluster tightly. Low Dice
                cases scatter widely across the confidence range. Why? Because when predictions are good, overconfident
                estimates are less wrong—so the correlation looks strong. When predictions fail, the model's confidence
                varies wildly, revealing uncertainty.</p>
<p><strong>The bias problem:</strong> Spearman correlation and AURC are biased by model performance. They
                reflect dataset statistics, not per-case safety. High AURC does not guarantee clinical translatability
                or practical safety outcomes.</p>
<p><strong>The threshold problem:</strong> Clinical deployment requires: "Accept cases where uncertainty &lt;
                    U*, reject otherwise." But Spearman ρ and AURC never define U*—the decision boundary needed for safe
                    automation. A high-correlation method still has scatter, with cases where high uncertainty pairs
                    with acceptable error (false rejections) or low uncertainty with high error (false acceptances).</p>
<p><strong>The solution:</strong> Safety-constrained evaluation. Instead of ranking methods, define
                        a quality threshold Q (e.g., Dice ≥ 0.7) and risk tolerance R (e.g., 5% failure rate), then find
                        U* that maximizes automation while guaranteeing worst-case safety bounds. Next tabs explain the
                        protocol.</p>
</section>
<section>
<h4>Methods (Methods tab) — Presenter Script (≈0:30)</h4>
<p>Protocol: choose a quality threshold Q and risk tolerance R, then find uncertainty threshold U* that
                maximizes automation gain subject to r(t) ≤ R. Use bootstrap resampling to compute conservative lower
                bounds (G_low) for automation and to generate confidence intervals for accepted-case performance.</p>
</section>
<section>
<h4>Results (Results tab) — Presenter Script (≈0:25)</h4>
<p>Results are dataset dependent: some datasets yield higher automation gains under the same R and Q.
                Reporting G_low and performance CIs provides interpretable, conservative guarantees for deployment.</p>
</section>
<section>
<h4>Transition</h4>
<p>Next: we implement this evaluation logic in Qually to operationalize safety-constrained QA.</p>
</section>
</aside>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="60" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 31.82%;"></div>
</div>
<div aria-label="Slide 6" class="slide-counter">6</div>
</section>
<script>
    (function () {
        const root = document.querySelector('[data-node-id="esann-eval"]');
        if (!root) return;

        const introBtn = root.querySelector('#intro-toggle');
        const methodsBtn = root.querySelector('#methods-toggle');
        const resultsBtn = root.querySelector('#results-toggle');
        const panelIntro = root.querySelector('#slide6-panel-intro');
        const panelMethods = root.querySelector('#slide6-panel-methods');
        const panelResults = root.querySelector('#slide6-panel-results');

        if (!introBtn || !methodsBtn || !resultsBtn || !panelIntro || !panelMethods || !panelResults) {
            console.warn('Slide 6 multi-tab: missing elements');
            return;
        }

        // Local augmentation: announce the active panel to assistive technologies.
        (function () {
            const aroot = document.querySelector('[data-node-id="esann-eval"]');
            if (!aroot) return;
            const panels = Array.from(aroot.querySelectorAll('#slide6-panel-intro, #slide6-panel-methods, #slide6-panel-results'));
            const live = aroot.querySelector('[aria-live]') || (function () { const d = document.createElement('div'); d.className = 'visually-hidden'; d.setAttribute('aria-live', 'polite'); aroot.appendChild(d); return d; })();

            function updateLive() {
                const active = panels.find(p => !p.hidden && p.getAttribute('aria-hidden') !== 'true') || panels[0];
                const caption = active ? (active.querySelector('.panel-caption') || active.querySelector('h3') || active) : null;
                live.textContent = caption ? (caption.textContent || '').trim() : '';
            }

            updateLive();
            const obs = new MutationObserver(updateLive);
            panels.forEach(p => obs.observe(p, { attributes: true, attributeFilter: ['hidden', 'aria-hidden'] }));
        })();

        // Provide robust local fallbacks for the page-level helpers if they are not present yet
        function animateSwitch(panel) {
            if (typeof window.animateSwitch === 'function') { window.animateSwitch(panel); return; }
            // Simple non-animated switch: show target panel and hide others
            [panelIntro, panelMethods, panelResults].forEach(p => {
                const show = (p === panel);
                p.hidden = !show;
                p.setAttribute('aria-hidden', show ? 'false' : 'true');
            });
            setButtonStates();
            // Load any lazy iframe inside the newly shown panel (if any)
            try {
                const iframe = panel.querySelector('iframe[data-src]');
                if (iframe && !iframe.getAttribute('src')) {
                    iframe.setAttribute('src', iframe.getAttribute('data-src'));
                    iframe.setAttribute('data-lazy-loaded', '');
                }
            } catch (e) { /* ignore */ }
        }

        function setButtonStates() {
            const buttons = [introBtn, methodsBtn, resultsBtn];
            buttons.forEach(btn => {
                const panel = root.querySelector(btn.getAttribute('aria-controls'));
                const active = panel && panel.getAttribute('aria-hidden') !== 'true';
                btn.classList.toggle('active', active);
                btn.setAttribute('aria-selected', active ? 'true' : 'false');
            });
        }
        introBtn.addEventListener('click', () => animateSwitch(panelIntro));
        introBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); introBtn.click(); } });
        methodsBtn.addEventListener('click', () => animateSwitch(panelMethods));
        methodsBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); methodsBtn.click(); } });
        resultsBtn.addEventListener('click', () => animateSwitch(panelResults));
        resultsBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); resultsBtn.click(); } });

        // Initialize states
        setButtonStates();

        // Lazy-load slide iframe when visible to avoid loading heavy embeds on initial page load
        (function () {
            const iframe = document.querySelector('[data-element-id="slide6-img-scatter-dice-confidence"].lazy-iframe');
            if (!iframe) return;
            const viewport = iframe.closest('.iframe-viewport');

            function loadIframe() {
                if (iframe.getAttribute('src')) return;
                const src = iframe.dataset.src;
                if (src) {
                    iframe.src = src;
                    iframe.setAttribute('data-lazy-loaded', '');
                    iframe.addEventListener('load', () => { setTimeout(adjustResponsiveIframes, 50); }, { once: true });
                }
            }

            // Load when panel enters viewport
            const panel = document.getElementById('slide6-panel-intro');
            if (panel && 'IntersectionObserver' in window) {
                const obs = new IntersectionObserver((entries) => {
                    entries.forEach(e => {
                        if (e.isIntersecting) { loadIframe(); obs.disconnect(); }
                    });
                }, { threshold: 0.1 });
                obs.observe(panel);
            } else {
                // Fallback: load when user clicks the intro tab
                const introBtn = document.getElementById('intro-toggle');
                if (introBtn) introBtn.addEventListener('click', loadIframe);
                // Also attempt to load after a short idle period
                setTimeout(loadIframe, 2000);
            }

            // Also load on first pointer interaction inside the viewport: captures user intent and avoids "multiple clicks" problem
            if (viewport) {
                viewport.addEventListener('pointerdown', (e) => { if (!iframe.getAttribute('src')) loadIframe(); }, { passive: true, capture: true });
            }
        })();

        // Simplified: no dynamic scaling needed - CSS handles sizing via fixed figure heights
    })();
</script>

<section aria-roledescription="slide" class="slide-container" data-node-id="qually-context" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div style="color: white; font-size: 14px;">Qually</div>
</div>
<div style="padding: 30px 28px;">
<div style="display: flex; gap: 12px; align-items: flex-start; justify-content: space-between;">
<div style="flex: 1;">
<h2 class="slide-title fragment fade-up" data-element-id="slide7-title">
                    Radiotherapy treatment plan commissioning
                </h2>
<p class="slide-subtitle fragment fade-up">Quality Assurance of segmentation models</p>
</div>
<div aria-label="Slide tabs" class="tablist" role="tablist">
<button aria-controls="slide7-panel-context" aria-selected="true" class="tab active" id="slide7-tab-context" role="tab"><i aria-hidden="true" class="fas fa-hospital-user"></i>Context
                    &amp; Problem</button>
<button aria-controls="slide7-panel-qually" aria-selected="false" class="tab" id="slide7-tab-qually" role="tab"><i aria-hidden="true" class="fas fa-lightbulb"></i>QUALLY
                    Solution</button>
</div>
</div>
<div class="tabbed-pane" data-element-id="slide7-tabs" style="margin-top: 16px;">
<div class="tab-panels">
<div aria-hidden="false" aria-labelledby="slide7-tab-context" class="tab-panel" data-element-id="slide7-panel-context" id="slide7-panel-context" role="tabpanel">
<figure class="fragment fade-up method-visual" style="width:90%; max-height: 100%;" data-zoomable="true">
<img data-element-id="slide7-context-svg" loading="lazy" src="../QUALLY/context.svg" style="width:90%; max-height:auto; border-radius:8px; display:block; margin:0 auto;"/>
<figcaption class="panel-caption" style="text-align:center; margin-top:8px; font-size:12px; color:#333;">
                            AI is increasingly integrated into
                            treatment planning steps (segmentation, dose simulation), creating new QA challenges.
                        </figcaption>
</figure>
</div>
<div aria-hidden="true" aria-labelledby="slide7-tab-qually" class="tab-panel" data-element-id="slide7-panel-qually" hidden="" id="slide7-panel-qually" role="tabpanel">
<div class="tab-qually fragment fade-up" style="animation-delay:0.15s; display: flex; flex-direction: column; gap: 20px;">
<!-- First Row: Image (2/3) + Two Cards Stacked (1/3) -->
<div style="display: grid; grid-template-columns: 1.5fr 1fr; gap: 20px; align-items: start;">
<!-- Left: Main Image (2/3) -->
<figure class="fragment fade-up method-visual" style="display: flex; flex-direction: column; justify-content: center;" data-zoomable="true">
<img alt="QUALLY solution: data fingerprint and phantom generator working together" data-element-id="slide7-qually-svg" loading="lazy" src="../QUALLY/qually.svg" style="height:640px; border-radius:8px;"/>
<figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
<!-- Right: Two Cards Stacked (1/3) -->
<div>
<!-- Card 1: Fingerprint -->
<div style="display:flex; align-items:center; gap:12px; text-align:left; padding: 12px; 
                                    border-radius: 6px; background: rgba(106, 27, 154, 0.05); margin-top:48px;">
<div style="font-size: 28px; color: #6A1B9A; flex: 0 0 auto;">
<i aria-hidden="true" class="fas fa-fingerprint"></i>
</div>
<div style="flex:1;">
<h4 style="font-weight: 700; color: #6A1B9A; margin: 0 0 6px 0; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px;">
                                            Fingerprint</h4>
<p style="font-size: 12px; color: #333; margin: 0; line-height: 1.4;">Reveals
                                            coverage gaps in data and patient groups.</p>
</div>
</div>
<!-- Card 2: Generator -->
<div style="display:flex; align-items:center; gap:12px; text-align:left; padding: 12px; 
                                    margin-top:48px; border-radius: 6px; background: rgba(106, 27, 154, 0.05);">
<div style="font-size: 28px; color: #6A1B9A; flex: 0 0 auto;">
<i aria-hidden="true" class="fas fa-magic"></i>
</div>
<div style="flex:1;">
<h4 style="font-weight: 700; color: #6A1B9A; margin: 0 0 6px 0; font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px;">
                                            Generator</h4>
<p style="font-size: 12px; color: #333; margin: 0; line-height: 1.4;">Creates
                                            realistic synthetic test cases to close gaps.</p>
</div>
</div>
<div style="display:flex; align-items:center; gap:12px; text-align:left; padding: 12px; 
                                    margin-top:48px; border-radius: 6px; background: rgba(106, 27, 154, 0.08); 
                                    border-left: 4px solid #6A1B9A;">
<div style="font-size: 32px; color: #6A1B9A; flex: 0 0 auto;">
<i aria-hidden="true" class="fas fa-layer-group"></i>
</div>
<div style="flex:1;">
<h4 style="font-weight: 700; color: #6A1B9A; margin: 0 0 8px 0; font-size: 15px; text-transform: uppercase; letter-spacing: 0.5px;">
                                            Phantom Suite</h4>
<p style="font-size: 13px; color: #333; margin: 0; line-height: 1.4; font-style: italic;">
                                            Fast, auditable QA with minimal, representative test cases.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="70" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 36.36%;"></div>
</div>
<div aria-label="Slide 7" class="slide-counter">7</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — Radiotherapy QA Context (≈1:30)</h3>
<section>
<h4>Tab 1: Context &amp; Problem (≈0:45)</h4>
<p>Radiotherapy requires rigorous QA at every stage: patient imaging, organ and tumor segmentation, dose
                calculation, and treatment delivery. When AI enters the pipeline—especially for segmentation and dose
                simulation—clinicians need evaluation methods that match the complexity and stakes. Traditional robust
                optimization and statistical validation were designed for physics-based tools, not learned models. Even
                uncertainty quantification (UQ) alone cannot reliably detect out-of-distribution cases or capture
                task-dependent failure modes, as we've documented in our prior work. This is why we need QA protocols
                specifically tailored for AI commissioning in clinical workflows.</p>
</section>
<section>
<h4>Tab 2: QUALLY Solution (≈0:45)</h4>
<p>QUALLY addresses this gap with a task-driven framework that merges clinical expertise and data to
                characterize tasks, generate realistic phantoms, and distil a small, representative suite for efficient
                QA. The three core components are: 1) Task Fingerprint (WP1), which captures task characteristics for
                stratified evaluation; 2) Phantom Generator (WP2), which synthesizes realistic test cases from
                fingerprints; and 3) Phantom Suite (WP3), which curates a minimal, representative set of phantoms for
                fast, auditable QA. The outcome is patient-level risk stratification, reduced commissioning burden, and
                clinician-centered evaluation protocols.</p>
</section>
<section>
<h4>Backup Notes</h4>
<ul>
<li>Context: RT QA uses robust optim + stats; AI now in critical steps (segmentation, dose).</li>
<li>Gap: Traditional QA unsuitable for AI; UQ alone insufficient for OOD/task-specific failures.</li>
<li>QUALLY: Task fingerprint + phantom generator + phantom suite = patient-centric, efficient QA.</li>
</ul>
</section>
</aside>
</section>
<script>
    (function () {
        const root = document.querySelector('[data-node-id="qually-context"]');
        if (!root) return;

        const contextBtn = root.querySelector('#slide7-tab-context');
        const quallyBtn = root.querySelector('#slide7-tab-qually');
        const panelContext = root.querySelector('#slide7-panel-context');
        const panelQually = root.querySelector('#slide7-panel-qually');
        const tabs = [contextBtn, quallyBtn].filter(Boolean);

        let current = panelContext;

        function setButtonStates() {
            tabs.forEach(tab => {
                const isActive = (tab === (current === panelContext ? contextBtn : quallyBtn));
                tab.classList.toggle('active', isActive);
                tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
                tab.setAttribute('tabindex', isActive ? '0' : '-1');
            });
        }

        let isAnimating = false;

        function animateSwitch(target) {
            if (!target || target === current || isAnimating) return;
            isAnimating = true;

            target.hidden = false;
            target.setAttribute('aria-hidden', 'false');

            setTimeout(() => {
                if (current) {
                    current.hidden = true;
                    current.setAttribute('aria-hidden', 'true');
                }
                current = target;
                setButtonStates();
                isAnimating = false;
            }, 0);
        }

        if (contextBtn) {
            contextBtn.addEventListener('click', () => animateSwitch(panelContext));
            contextBtn.addEventListener('keydown', e => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    contextBtn.click();
                }
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    quallyBtn.focus();
                    quallyBtn.click();
                }
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    quallyBtn.focus();
                    quallyBtn.click();
                }
            });
        }

        if (quallyBtn) {
            quallyBtn.addEventListener('click', () => animateSwitch(panelQually));
            quallyBtn.addEventListener('keydown', e => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    quallyBtn.click();
                }
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    contextBtn.focus();
                    contextBtn.click();
                }
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    contextBtn.focus();
                    contextBtn.click();
                }
            });
        }

        setButtonStates();
    })();
</script>

<section aria-roledescription="slide" class="slide-container" data-node-id="qually-components" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div style="color: white; font-size: 14px;">QUALLY</div>
</div>
<div style="padding: 20px 28px;">
<div style="display: flex; gap: 12px; align-items: flex-start; justify-content: space-between;">
<div style="flex: 1;">
<h2 class="slide-title fragment fade-up" data-element-id="slide8-title">
                    QUALLY: Core Components
                </h2>
<p class="slide-subtitle fragment fade-up">Beyond average metrics → detailed performance
                    characterization</p>
</div>
<div aria-label="Slide tabs" class="tablist" role="tablist">
<button aria-controls="slide8-panel-fingerprint" aria-selected="true" class="tab active" id="slide8-tab-fingerprint" role="tab"><i aria-hidden="true" class="fas fa-database"></i>Data
                    Fingerprint</button>
<button aria-controls="slide8-panel-generator" aria-selected="false" class="tab" id="slide8-tab-generator" role="tab"><i aria-hidden="true" class="fas fa-cogs"></i>Phantom
                    Generator</button>
<button aria-controls="slide8-panel-suite" aria-selected="false" class="tab" id="slide8-tab-suite" role="tab"><i aria-hidden="true" class="fas fa-flask"></i>Phantom
                    Suite</button>
</div>
</div>
<div class="tabbed-pane" data-element-id="slide8-tabs">
<div class="tab-panels">
<div aria-hidden="false" aria-labelledby="slide8-tab-fingerprint" class="tab-panel" data-element-id="slide8-panel-fingerprint" id="slide8-panel-fingerprint" role="tabpanel">
<figure class="fragment fade-up method-visual" style="width:90%; max-height:100%; margin-left: 5%; margin-right:5%;" data-zoomable="true">
<img alt="Data fingerprint: feature extraction and characterization" data-element-id="slide8-fig-fingerprint" loading="lazy" src="../QUALLY/fingerprint.svg" style="width:100%; height:auto; border-radius:8px; display:block; margin:auto auto; "/>
<figcaption style="font-size:12px; color:#666; margin-top:10px; line-height:1.4; text-align:center;">
                            Feature extraction and clinical cues for data characterization and conformity detection.
                        </figcaption>
</figure>
</div>
<div aria-hidden="true" aria-labelledby="slide8-tab-generator" class="tab-panel" data-element-id="slide8-panel-generator" hidden="" id="slide8-panel-generator" role="tabpanel">
<div class="fragment fade-up" style="display:grid; grid-template-columns: 1fr 1fr; gap:24px; align-items:center; animation-delay:0.15s; 
                    margin-left: 15%; margin-right:10%;; margin-top:48px;">
<figure class="fragment fade-up method-visual" data-zoomable="true">
<img data-element-id="slide8-fig-generator" loading="lazy" src="../QUALLY/phantom.svg" style="max-width:800px; height:600px; border-radius:8px;"/>
<figcaption style="font-size:12px; color:#666; margin-top:10px; line-height:1.4; text-align:center;">
                                Interactive synthesis from textual prompts
                            </figcaption>
</figure>
<div style="background: #F8F9FA; width: 80%; border-radius: 8px; padding: 16px; border-left: 3px solid #9933CC;">
<p style="font-size:13px; color:#333; margin:0 0 12px 0; line-height:1.6;">
<strong>Purpose:</strong> Create targeted synthetic patients
                            </p>
<div style="display:flex; align-items:start; gap:10px; margin-bottom:12px;">
<i aria-hidden="true" class="fas fa-wand-magic-sparkles" style="color:#9933CC; font-size:16px; margin-top:2px; flex-shrink:0;"></i>
<p style="font-size:12px; color:#333; margin:0; line-height:1.5;">
<strong>Promptable:</strong> Text &amp; visual control
                                </p>
</div>
<div style="display:flex; align-items:start; gap:10px;">
<i aria-hidden="true" class="fas fa-shield-alt" style="color:#9933CC; font-size:16px; margin-top:2px; flex-shrink:0;"></i>
<p style="font-size:12px; color:#333; margin:0; line-height:1.5;">
<strong>Ensures:</strong> Clinical fidelity &amp; edge cases
                                </p>
</div>
</div>
</div>
</div>
<div aria-hidden="true" aria-labelledby="slide8-tab-suite" class="tab-panel" data-element-id="slide8-panel-suite" hidden="" id="slide8-panel-suite" role="tabpanel">
<figure class="fragment fade-up method-visual" style="max-height:640px; width:70%; margin-left: auto; object-fit:contain; margin-left: 12%; margin-right:12%;" data-zoomable="true">
<img alt="Phantom suite: representative set of phantoms" data-element-id="slide8-fig-suite" loading="lazy" src="../QUALLY/suite.svg" style="width:100%; height:auto; max-height:640px; background:none; display:block;"/>
<figcaption style="font-size:16px; color:#666; margin-top:10px; line-height:1.4; text-align:center;">
                            Minimal representative coverage of clinical scenarios
                        </figcaption>
</figure>
</div>
</div>
</div>
</div>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="80" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 40.91%;"></div>
</div>
<div aria-label="Slide 8" class="slide-counter">8</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — QUALLY Core Components (≈1:30)</h3>
<section>
<h4>Tab 1: Data Fingerprint (≈0:30)</h4>
<p>Data fingerprint characterizes the data itself using clinical expertise and analysis. When task-specific,
                it enables stratified, patient-centric testing and helps identify which patients or scenarios are most
                representative or at risk, and it guides the Phantom Generator to create targeted synthetic images that
                complement the real dataset and inform test-set construction and QA.</p>
</section>
<section>
<h4>Tab 2: Phantom Generator (≈0:30)</h4>
<p>The phantom generator is a fully interactive, controllable environment that synthesizes realistic patient
                images from fingerprint-driven prompts. By taking insights from the fingerprint it creates targeted
                synthetic cases to augment the dataset and fill diagnostic gaps. It enforces clinical fidelity by
                validating
                Hounsfield Unit levels, slice consistency, and dosimetric constraints to ensure generated phantoms meet
                radiotherapy standards.</p>
</section>
<section>
<h4>Tab 3: Phantom Suite (≈0:30)</h4>
<p>The phantom suite curates a minimal, representative set of phantoms from the generator—selected using
                insights from the fingerprint—so it covers task extremes, anatomical variation, and edge cases. This
                lean suite enables fast, auditable QA, provides targeted synthetic cases to complement the dataset, and
                supports patient-level risk interpolation without the computational burden of exhaustive testing.</p>
</section>
<section>
<h4>Backup Notes</h4>
<ul>
<li>Fingerprint: data characterization via clinical expertise; task-specific stratification possible.
                </li>
<li>Generator: controlled synthesis of realistic phantoms; enforces clinical fidelity (HU, dosimetry,
                    anatomy).</li>
<li>Suite: minimal representative set; enables fast, efficient QA and patient-level triage.</li>
<li>Flow: Fingerprint → prompts → Generator → Suite selection → efficient QA.</li>
</ul>
</section>
</aside>
</section>
<script>
    (function () {
        const root = document.querySelector('[data-node-id="qually-components"]');
        if (!root) return;

        const fingerprintBtn = root.querySelector('#slide8-tab-fingerprint');
        const generatorBtn = root.querySelector('#slide8-tab-generator');
        const suiteBtn = root.querySelector('#slide8-tab-suite');
        const panelFingerprint = root.querySelector('#slide8-panel-fingerprint');
        const panelGenerator = root.querySelector('#slide8-panel-generator');
        const panelSuite = root.querySelector('#slide8-panel-suite');
        const tabs = [fingerprintBtn, generatorBtn, suiteBtn].filter(Boolean);

        let current = panelFingerprint;

        function setButtonStates() {
            tabs.forEach(tab => {
                const isActive = (
                    (tab === fingerprintBtn && current === panelFingerprint) ||
                    (tab === generatorBtn && current === panelGenerator) ||
                    (tab === suiteBtn && current === panelSuite)
                );
                tab.classList.toggle('active', isActive);
                tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
                tab.setAttribute('tabindex', isActive ? '0' : '-1');
            });
        }

        let isAnimating = false;

        function animateSwitch(target) {
            if (!target || target === current || isAnimating) return;
            isAnimating = true;

            target.hidden = false;
            target.setAttribute('aria-hidden', 'false');

            setTimeout(() => {
                if (current) {
                    current.hidden = true;
                    current.setAttribute('aria-hidden', 'true');
                }
                current = target;
                setButtonStates();
                isAnimating = false;
            }, 0);
        }

        function setupTabButton(btn, panel) {
            if (!btn) return;
            btn.addEventListener('click', () => animateSwitch(panel));
            btn.addEventListener('keydown', e => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    btn.click();
                }
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    const idx = tabs.indexOf(btn);
                    const next = tabs[(idx + 1) % tabs.length];
                    next.focus();
                    next.click();
                }
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    const idx = tabs.indexOf(btn);
                    const next = tabs[(idx - 1 + tabs.length) % tabs.length];
                    next.focus();
                    next.click();
                }
            });
        }

        setupTabButton(fingerprintBtn, panelFingerprint);
        setupTabButton(generatorBtn, panelGenerator);
        setupTabButton(suiteBtn, panelSuite);

        setButtonStates();
    })();
</script>

<section aria-roledescription="slide" class="slide-container" data-node-id="roadmap-node-ongoing" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
<div style="color: white; font-size: 14px;">Ongoing</div>
</div>
<!-- changelog: rationale: split tab 2 into separate Dataset Description and Error Prediction tabs for clearer content organization; source: slides/09.html#L20-L47 -->
<!-- CONTENT: Three-tab layout -->
<div style="padding: 8px 26px 18px;">
<div style="display: flex; gap: 12px; align-items: flex-start; justify-content: space-between;">
<!-- HEADER with title and tabs -->
<div style="padding: 18px 26px 8px;">
<h2 class="slide-title fragment fade-up" data-element-id="slide23-title" style="font-size: 24px; margin-bottom: 12px;">
<i aria-hidden="true" class="fas fa-fingerprint" style="color: #0066CC; margin-right: 10px;"></i>
                    Task Fingerprinting &amp; Clustering
                </h2>
<p class="slide-subtitle fragment fade-up">
                    Ongoing work on Natural Images</p>
</div>
<!-- Tab Navigation -->
<div aria-label="Task Fingerprinting sections" class="tablist" role="tablist">
<button aria-controls="slide23-panel-intro" aria-selected="true" class="tab active" data-element-id="slide23-tab-intro" id="slide23-tab-intro" role="tab">
<i aria-hidden="true" class="fas fa-book-open"></i> Introduction &amp; Context
                </button>
<button aria-controls="slide23-panel-dataset" aria-selected="false" class="tab" data-element-id="slide23-tab-dataset" id="slide23-tab-dataset" role="tab">
<i aria-hidden="true" class="fas fa-tag"></i> Dataset Description
                </button>
</div>
</div>
<div class="tabbed-pane" data-element-id="slide23-tabs">
<div class="tab-panels">
<!-- TAB 1: Introduction & Context -->
<div aria-hidden="false" aria-labelledby="slide23-tab-intro" class="tab-panel" data-element-id="slide23-panel-intro" id="slide23-panel-intro" role="tabpanel">
<div style="display: grid; grid-template-columns: 1fr 1.4fr; gap: 16px; margin-bottom: auto; margin-top: 48px;">
<div style="margin-left:12px">
<!-- Opening: Proof-of-Concept Strategy -->
<div class="slide-card fragment fade-up" style="padding: 14px; margin-bottom: 14px; background: linear-gradient(135deg, #E3F2FD, #BBDEFB);">
<h3 style="font-size: 15px; font-weight: 600; color: #0066CC; margin-bottom: 10px;">
                                    Common Object in COntext dataset (COCO)
                                </h3>
<ul style="font-size: 13px; color: #003366; margin: 0; 
                                    line-height: 1.8; padding-left: 20px; margin-left:12px;">
<li>Pretrained model available for all tasks</li>
<li>Well-annotated, large dataset</li>
<li>Pre-trained vision-language models can be used</li>
</ul>
</div>
<!-- Next Steps & Future Work -->
<div class="slide-card fragment fade-up" style="padding: 12px; background: linear-gradient(135deg, #E3F2FD, #BBDEFB); border-left: 3px solid #0066CC;">
<h4 style="font-size: 13px; font-weight: 600; color: #0066CC; margin: 0 0 8px;">
<i aria-hidden="true" class="fas fa-road" style="margin-right: 6px;"></i>
                                    Next Phases:
                                </h4>
<ul style="font-size: 12px; margin-left:12px; color: #003366; margin: 0; 
                                    line-height: 1.6; padding-left: 20px;">
<li><strong>CT</strong> Images</li>
<li>Domain-specific medical cues</li>
<li>Targeted phantom generation</li>
</ul>
</div>
</div>
<div>
<!-- COCO Example Image -->
<figure class="slide-card fragment fade-up method-visual" data-element-id="slide23-coco-example" style="width:100%; height:auto; border-radius:8px; margin-bottom:8px; overflow:hidden;" data-zoomable="true">
<img alt="COCO dataset examples showing classification, detection, segmentation and captioning" loading="lazy" src="../coco.png" style="display:block; max-height:100%; width:100%; object-fit:contain; box-shadow: none;"/>
<figcaption style="font-size: 12px; color: #616161; text-align: center;">
                                    COCO: classification, object detection and segmentation and captioning.
                                </figcaption>
</figure>
</div>
</div>
</div>
<!-- TAB 2: Dataset Description -->
<div aria-hidden="true" aria-labelledby="slide23-tab-dataset" class="tab-panel" data-element-id="slide23-panel-dataset" hidden="" id="slide23-panel-dataset" role="tabpanel">
<div style="display: grid; grid-template-columns: 1.6fr 1fr; gap: 16px; margin-top: 48px;">
<div>
<!-- changelog: rationale: reproduced the generation/gallery pattern from slides 3 & 5 for
                                    consistent UX and keyboard accessibility; source: slides/03.html (generation-gallery) -->
<div aria-hidden="false" class="generation-gallery" style="display:flex;align-items:center;">
<div class="generation-main" style="position:relative; display:flex; align-items:center; justify-content:center;">
<button aria-label="Previous gallery image" class="generation-prev" style="background:none;border:none;cursor:pointer;font-size:26px;line-height:1;padding:6px 10px;" role="button" tabindex="0">‹</button>
<figure style="text-align:center;" class="method-visual" data-zoomable="true">
<img id="slide23-gen-main" loading="lazy" src="../clusters/yolov11-seg.png" style="max-width:760px; height:480px; object-fit:contain; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.1);"/>
<figcaption style="font-size:11px; color:#666; margin-top:6px;"></figcaption></figure>
<button aria-label="Next gallery image" class="generation-next" style="background:none;border:none;cursor:pointer;font-size:26px;line-height:1;padding:6px 10px;" role="button" tabindex="0">›</button>
</div>
<div class="generation-thumbs" role="list" style="display:flex;flex-direction:row;gap:8px;justify-content:center;margin-left:12px;">
<button aria-label="Show YOLO embeddings" aria-pressed="false" class="generation-thumb" data-caption="YOLO embeddings" data-src="../clusters/yolov11-seg.png" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="YOLO thumbnail" loading="lazy" src="../clusters/yolov11-seg.png" style="width:48px;height:64px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show DINOv3 embeddings" aria-pressed="false" class="generation-thumb" data-caption="DINOv3 embeddings" data-src="../clusters/dinov3.png" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="DINOv3 thumbnail" loading="lazy" src="../clusters/dinov3.png" style="width:48px;height:64px;object-fit:cover;border-radius:4px;"/>
</button>
<button aria-label="Show CLIP embeddings" aria-pressed="false" class="generation-thumb" data-caption="CLIP embeddings" data-src="../clusters/clip.png" style="border:none;background:none;cursor:pointer;padding:0;" role="button" tabindex="0">
<img alt="CLIP thumbnail" loading="lazy" src="../clusters/clip.png" style="width:48px;height:64px;object-fit:cover;border-radius:4px;"/>
</button>
</div>
</div>
<!-- changelog: rationale: place gallery thumbnails below the main image for clearer visual hierarchy and consistent mobile behavior; source: slides/09.html (slide23-cluster-gallery CSS) -->
<script>
                                (function initSlide23Gallery() {
                                    const panel = document.querySelector('#slide23-panel-dataset');
                                    if (!panel) return;
                                    const gallery = panel.querySelector('.generation-gallery');
                                    if (!gallery) return;
                                    const main = gallery.querySelector('#slide23-gen-main');
                                    const caption = gallery.querySelector('#slide23-gen-caption');
                                    const thumbs = Array.from(gallery.querySelectorAll('.generation-thumb'));
                                    const prev = gallery.querySelector('.generation-prev');
                                    const next = gallery.querySelector('.generation-next');
                                    let index = 0;
                                    const update = i => {
                                        const btn = thumbs[i];
                                        const src = btn.getAttribute('data-src');
                                        const cap = btn.getAttribute('data-caption');
                                        main.src = src;
                                        main.alt = btn.querySelector('img').alt || cap;
                                        caption.textContent = cap;
                                        thumbs.forEach((t, idx) => t.setAttribute('aria-pressed', idx === i ? 'true' : 'false'));
                                        index = i;
                                    };
                                    thumbs.forEach((t, i) => {
                                        t.addEventListener('click', () => update(i));
                                        t.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); update(i); } });
                                    });
                                    prev && prev.addEventListener('click', () => update((index - 1 + thumbs.length) % thumbs.length));
                                    next && next.addEventListener('click', () => update((index + 1) % thumbs.length));
                                    gallery.addEventListener('keydown', e => { if (e.key === 'ArrowLeft') prev && prev.click(); if (e.key === 'ArrowRight') next && next.click(); });
                                    update(0);
                                })();
                            </script>
</div>
<div>
<!-- Embedding Approaches -->
<div class="slide-card fragment fade-up" style="animation-delay: 0.2s; padding: 14px; margin-bottom: 14px; background: linear-gradient(135deg, #E8F5E9, #C8E6C9);">
<h4 style="font-size: 16px; font-weight: 600; color: #2E7D32; margin-bottom: 10px;">
<i aria-hidden="true" class="fas fa-cube" style="margin-right: 6px;"></i>
                                    Embedding Models Tested
                                </h4>
<ul style="font-size: 14px; color: #1B5E20; margin: 0; line-height: 1.7; padding-left: 32px;">
<li><strong>Task-specific:</strong> YOLO (detection/segmentation)</li>
<li><strong>Vision:</strong> DINO</li>
<li><strong>Vision-Language:</strong> CLIP</li>
</ul>
</div>
<!-- Dimensionality Reduction -->
<div class="slide-card fragment fade-up" style="animation-delay: 0.2s; padding: 14px; background: linear-gradient(135deg, #E3F2FD, #BBDEFB);">
<h4 style="font-size: 16px; font-weight: 600; color: #0066CC; margin-bottom: 10px;">
<i aria-hidden="true" class="fas fa-compress-arrows-alt" style="margin-right: 6px;"></i>
                                    Dimensionality Reduction
                                </h4>
<ul style="font-size: 14px; color: #003366; margin: 0; line-height: 1.7; padding-left: 32px;">
<li><strong>UMAP:</strong> preserve global structure</li>
<li><strong>t-SNE:</strong> emphasize local clusters</li>
</ul>
</div>
<div class="slide-card fragment fade-up" style="animation-delay: 0.2s; padding: 14px; margin-top: 14px; margin-bottom: 14px; background: linear-gradient(135deg, #FFF3E6, #FFE0B2);">
<h4 style="font-size: 14px; font-weight: 600; color: #E65100; margin-bottom: 10px;">
<i aria-hidden="true" class="fas fa-network-wired" style="margin-right: 6px;"></i>
                                    K-Nearest Neighbors Regression
                                </h4>
<p style="font-size: 12px; color: #BF360C; margin: 0; line-height: 1.7; padding-left: 20px;">
<strong>Predict segmentation error</strong> from embeddings
                                </p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="90" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 45.45%;"></div>
</div>
<div aria-label="Slide 9" class="slide-counter">9</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — Task Fingerprinting (≈1:00)</h3>
<section>
<h4>Presenter Script (≈1:00)</h4>
<p>Task fingerprinting is about actionable characterization. After testing embeddings from CLIP, DINO, ViT
                and ResNet, we found generic embeddings poorly aligned with segmentation errors. We now focus on
                prediction-space distances—directly comparing model outputs—to build fingerprints that correlate with
                failure modes and are useful for clustering, risk stratification, and targeted phantom generation.</p>
</section>
<h4>Context from Slide 10 (~25 seconds)</h4>
<p>We identified bottlenecks: heterogeneity, fragile evaluation, and deployment risk. Now we focus on
            systematically identifying which tasks matter most—task fingerprinting.</p>
<h4>What Is Task Fingerprinting? (~40 seconds)</h4>
<p><strong>Goal:</strong> Extract medical cues to cluster tasks by failure risk. If tasks with similar cues
            share error patterns, we can stratify test sets early.<br/><strong>Approach:</strong> Characterized
            embeddings from CLIP, DINO, ViT, and ResNet on radiotherapy images to see if they naturally cluster by
            error.</p>
<h4>Early Results &amp; KNN Lesson (~50 seconds)</h4>
<p><strong>Tested:</strong> KNN predicting error directly from embeddings (CLIP, DINO, ViT,
            ResNet).<br/><strong>Finding:</strong> KNN inefficient—no better than
            baseline.<br/><strong>Implication:</strong> Pre-trained embedding spaces do not cluster medical segmentation
            errors; we need task-specific characterization.</p>
<h4>Path Forward (~35 seconds)</h4>
<p>Pivot to <strong>prediction-space distances</strong>—compare model outputs rather than embeddings. This
            aligns with our thesis: evaluate clinically meaningful differences via prediction-to-prediction loss.</p>
<h4>Bridge to Slide 12 (~10 seconds)</h4>
<p>With a validated fingerprinting approach, we can prototype the Phantom Suite—our end-to-end test set builder.
        </p>
</aside>
</section>


<section aria-roledescription="slide" class="slide-container" data-node-id="slide-contributions-detailed" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
</div>
<div style="padding: 22px 28px;">
<h2 class="slide-title fragment fade-up" data-element-id="slide11-title" style="font-size: 28px; font-weight: 700; color: #003366; margin-bottom: 18px;">
<i aria-hidden="true" class="fas fa-cubes" style="color: #0066CC; margin-right: 10px;"></i>
            Credits
        </h2>
<!-- changelog: rationale: change layout to 3-pillars in top row and move 'Other Credits' as
             a horizontal full-width card below with 2-column content; source: slides/10.html (this file) -->
<!-- Three Pillars in a row -->
<div class="pillars-container" style="max-width: 100%; height: 100%; margin: 48px auto; 
            display: flex; flex-direction: row; gap: 12px; padding: 0 20px; margin-bottom: 12px; width:90%; justify-items: center;">
<!-- PILLAR 1: QA OF LABELS + IMAGES -->
<div class="pillar-card fragment fade-up" data-element-id="pillar-1-labels" data-pillar="1" style="animation-delay: 0.1s;">
<div class="pillar-card-header" style="background: #F8F9FA; padding: 14px; border-radius: 8px 8px 0 0; color: #0D47A1; border-bottom: 3px solid #1565C0;">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
<i aria-hidden="true" class="fas fa-image" style="font-size: 16px; color: #1565C0; margin-top:8px; margin-left:0px;"></i>
<i aria-hidden="true" class="fas fa-tags" style="font-size: 16px; color: #1565C0; margin-left:-16px;"></i>
<h3 style="margin: 0; font-size: 18px; font-weight: 700;">Dataset QA</h3>
</div>
<div style="font-size: 13px; line-height: 1.4; color: #1565C0;">
                        Annotations and Images quality
                    </div>
</div>
<div class="pillar-card-body" style="background: white; padding: 14px; border-radius: 0 0 8px 8px; border: 2px solid #E9ECEF; border-top: none;">
<div style="font-size: 12px; color: #424242; margin: 0; line-height: 1.6;">
<!-- Publications -->
<div aria-hidden="true" class="pillar-pubs" style="margin-top:8px; font-size:12px; grid-column: 1 / -1;">
<span class="pub-entry authored">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Rimez, Legay &amp; Macq — NiDS 2024</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span><br/>
<span class="pub-entry">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Benkedadra, Rimez et al. — MIPR 2024</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span>
</div>
<!-- Future work subcard -->
<div aria-label="Future work: dataset QA" class="future-work" data-element-id="pillar-1-future">
<span aria-hidden="true" class="future-icon">🚀</span>
<div><strong>Future work</strong></div>
<div style="margin-left: 12px;">
<p>Phantom generator</p>
<p>Data fingerprint</p>
</div>
</div>
</div>
</div>
</div>
<!-- PILLAR 2: QA OF PREDICTIONS -->
<div class="pillar-card fragment fade-up" data-element-id="pillar-3-predictions" data-pillar="3" style="animation-delay: 0.2s;">
<div class="pillar-card-header" style="background: #F8F9FA; padding: 14px; border-radius: 8px 8px 0 0; color: #4527A0; border-bottom: 3px solid #5E35B1;">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
<i aria-hidden="true" class="fas fa-chart-line" style="font-size: 24px; color: #5E35B1;"></i>
<h3 style="margin: 0; font-size: 18px; font-weight: 700;">Prediction QA</h3>
</div>
<div style="font-size: 13px; line-height: 1.4; color: #5E35B1;">
                        Quantify and predict the quality of model predictions
                    </div>
</div>
<div class="pillar-card-body" style="background: white; padding: 14px; border-radius: 0 0 8px 8px; border: 2px solid #E9ECEF; border-top: none;">
<div style="font-size: 12px; color: #424242; margin: 0; line-height: 1.6;">
<!-- Publications -->
<div aria-hidden="true" class="pillar-pubs" style="margin-top:8px; font-size:12px;">
<span class="pub-entry authored">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Rimez, J.A. Lee &amp; A-M. B-M. — ESTRO</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span>
</div>
<div aria-label="Future work: prediction QA" class="future-work" data-element-id="pillar-2-future">
<span aria-hidden="true" class="future-icon">🚀</span>
<div><strong>Future work</strong></div>
<p style="margin-left: 12px;">
                                Data fingerprint and UQ
                            </p>
</div>
</div>
</div>
</div>
<!-- PILLAR 3: COMPREHENSIVE MODEL QA (moved to top row) -->
<div class="pillar-card fragment fade-up" data-element-id="pillar-3-predictions" data-pillar="3" style="animation-delay: 0.25s;">
<div class="pillar-card-header" style="background: #F8F9FA; padding: 14px; border-radius: 8px 8px 0 0; color: #7B1FA2; border-bottom: 3px solid #5E35B1;">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
<i aria-hidden="true" class="fas fa-microscope" style="font-size: 24px; color: #7B1FA2; margin-right: 4px;"></i>
<h3 style="margin: 0; font-size: 18px; font-weight: 700;">Model QA</h3>
</div>
<div style="font-size: 13px; line-height: 1.4; color: #7B1FA2;">
                        Comprehensive characterization of model performances
                    </div>
</div>
<div class="pillar-card-body" style="background: white; padding: 14px; border-radius: 0 0 8px 8px; border: 2px solid #E9ECEF; border-top: none;">
<div style="font-size: 12px; color: #424242; margin: 0; line-height: 1.6;">
<!-- Publications -->
<div aria-hidden="true" class="pillar-pubs" style="margin-top:8px; font-size:12px;">
<span class="pub-entry authored">
<i aria-hidden="true" class="fas fa-book pub-icon" title="publication"></i>
<span class="pub-text">Rimez, J.A. Lee &amp; A-M. B-M. — ESANN 2026</span>
<span class="pub-badges"><i aria-hidden="true" class="fas fa-check-circle pub-status accepted" title="accepted"></i></span>
</span>
</div>
<!-- Future work subcard -->
<div aria-label="Future work: model QA" class="future-work" data-element-id="pillar-3-future">
<span aria-hidden="true" class="future-icon">🚀</span>
<div><strong>Future work</strong> </div>
<div style="margin-left: 12px;">
<p>Extension to journal paper</p>
<p>Phantom suite</p>
</div>
</div>
</div>
</div>
</div>
</div>
<!-- Other Credits as full-width horizontal card below, content in two columns -->
<div class="pillars-row-2" style="justify-content: center; display:center;
                margin-left:auto; margin-right:auto; margin-top: 48px; width:60%;">
<div aria-label="Additional credits" class="pillar-card fragment fade-up other-credits-card" data-element-id="other-credits-card" style="animation-delay: 0.3s; width:100%;">
<div class="pillar-card-header" style="background: #F8F9FA; padding: 14px; border-radius: 8px 8px 0 0; color: #FF6F00; border-bottom: 3px solid #FF6F00;">
<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
<i aria-hidden="true" class="fas fa-star" style="font-size: 24px; color: #FF6F00;"></i>
<h3 style="margin: 0; font-size: 18px; font-weight: 700;">Additional Credits</h3>
</div>
</div>
<div class="pillar-card-body other-credits-body" style="background: white; padding: 14px; border-radius: 0 0 8px 8px; border: 2px solid #E9ECEF; border-top: none;">
<div class="credits-column left" style="font-size: 12px; color: #424242; margin: 0; line-height: 1.6;">
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-graduation-cap pill-icon" style="color: #FF6F00;"></i>
<strong class="key-takeaway">ML course instructor (3 years)</strong>
</div>
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-book-open pill-icon" style="color: #FF6F00;"></i>
<strong class="key-takeaway">3 Master thesis supervisions</strong>
</div>
</div>
<div class="credits-column right" style="font-size: 12px; color: #424242; margin: 0; line-height: 1.6;">
<div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-lightbulb pill-icon" style="color: #FF6F00;"></i>
<strong>Innovation classes (5 credits course)</strong>
</div>
<div style="display: flex; align-items: center; gap: 8px;">
<i aria-hidden="true" class="fas fa-server pill-icon" style="color: #FF6F00;"></i>
<strong>HPC training (2 CECI formation)</strong>
</div>
</div>
</div>
</div>
</div>
</div>
<div aria-valuemax="100" aria-valuemin="0" aria-valuenow="100" class="progress-container" role="progressbar">
<div class="progress-bar" style="width: 50.0%;"></div>
</div>
<div aria-label="Slide 10" class="slide-counter">10</div>
<aside aria-label="Speaker notes" class="notes">
<h3>Speaker Notes — Contributions &amp; Acquired Credits (≈2:15)</h3>
<section>
<h4>Overview (≈20 seconds)</h4>
<p>This slide synthesizes four pillars of quality assurance: secure data &amp; annotation workflows,
                systematic image validation and synthetic data generation, uncertainty quantification for deployment
                risk, and comprehensive model evaluation for trustworthy AI in radiotherapy.</p>
</section>
<section>
<h4>Pillar 1: Label Quality &amp; Secure Workflows (≈25 seconds)</h4>
<p><strong>Contribution:</strong> SAMAS enables secure annotation peer-review for federated learning,
                published NiDS 2024.<br/>
<strong>Focus:</strong> Reducing annotation noise and establishing privacy-preserving quality
                workflows across multi-site clinical environments.<br/>
<strong>Credits:</strong> CyberWAL Workshop (Galaxia) participation and protocol development.
            </p>
</section>
<section>
<h4>Pillar 2: Image Quality &amp; Synthetic Data (≈25 seconds)</h4>
<p><strong>Contribution:</strong> CIA generates controlled synthetic data with systematic quality
                filtering and outlier detection, published MIPR 2024.<br/>
<strong>Focus:</strong> Improving model robustness through data augmentation and detecting quality
                artifacts.<br/>
<strong>Credits:</strong> TRAIL 2023 Workshop participation.
            </p>
</section>
<section>
<h4>Pillar 3: Prediction Quality &amp; Uncertainty (≈25 seconds)</h4>
<p><strong>Contribution:</strong> Recon-UQ quantifies segmentation uncertainty for risk-aware clinical
                deployment (ESTRO, ESANN 2026).<br/>
<strong>Focus:</strong> Enabling clinicians to flag uncertain predictions and make informed
                decisions about model recommendations.<br/>
<strong>Credits:</strong> Seminar presentations and validation protocol development.
            </p>
</section>
<section>
<h4>Pillar 4: Comprehensive Model Evaluation (≈30 seconds)</h4>
<p><strong>Contribution:</strong> QUALLY Suite provides systematic robustness benchmarks and
                clinical-use scenario testing for end-to-end evaluation.<br/>
<strong>Status:</strong> Ongoing work building on the ESTRO accepted paper and comprehensive
                evaluation protocols.
            </p>
</section>
<section>
<h4>Acquired Credits (≈15 seconds)</h4>
<p><strong>Teaching &amp; Supervision:</strong> 3 years as instructor for Machine Learning course;
                supervised 3 Master thesis projects.<br/>
<strong>Professional Development:</strong> Innovation &amp; entrepreneurship classes; HPC training (CECI
                formation).
            </p>
</section>
<section>
<h4>Future Work &amp; Funding (≈10 seconds)</h4>
<p>ESTRO and ESANN conference papers will be extended into journal extensions to provide deeper
                validation, larger cohorts, and clinical impact assessment. Funding commitment spans 3+ years,
                ensuring completion and clinical translation of these contributions.</p>
</section>
</aside>
</section>


<section aria-roledescription="slide" class="slide-container" data-node-id="roadmap-node-summary" role="group">
<div class="ucl-header">
<div class="ucl-logo">
<i aria-hidden="true" class="fas fa-university"></i>
<span>PhD Confirmation</span>
</div>
</div>
<div style="padding: 40px 48px; display: flex; flex-direction: column; justify-content: center; align-items: center; height: calc(720px - 140px);">
<!-- Thank You Title -->
<div class="fragment fade-up" data-element-id="thankyou-title" style="margin-bottom: 32px;">
<h1 style="font-size: 48px; font-weight: 700; background: linear-gradient(90deg, #003366, #0066CC); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-align: center; margin: 0;">
                Thank You
            </h1>
</div>
<!-- Questions Prompt with Arrow -->
<div class="fragment fade-up" data-element-id="questions-prompt" style="margin-bottom: 40px; display: flex; align-items: center; gap: 16px;">
<h2 style="font-size: 32px; font-weight: 600; color: #003366; margin: 0;">
                Questions?
            </h2>
<i aria-hidden="true" class="fas fa-arrow-right" style="color: #0066CC; font-size: 28px; animation: bounce-right 2s ease-in-out infinite;"></i>
</div>
<div class="progress-container">
<div class="progress-bar" style="width: 54.55%;"></div>
</div>
</div>
<!-- Interactive Scripts -->
<script>
        (function () {
            // Copy email to clipboard
            const copyEmailBtn = document.getElementById('btn_copy_email');
            if (copyEmailBtn) {
                copyEmailBtn.addEventListener('click', function () {
                    const email = 'dany.rimez@uclouvain.be';
                    navigator.clipboard.writeText(email).then(() => {
                        const originalText = this.innerHTML;
                        this.innerHTML = '<i class="fas fa-check" aria-hidden="true"></i> Copied!';
                        this.style.background = '#C8E6C9';
                        setTimeout(() => {
                            this.innerHTML = originalText;
                            this.style.background = '#E3F2FD';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy email:', err);
                    });
                });
            }

            // Toggle details styling
            const followupBox = document.getElementById('box_followup');
            if (followupBox) {
                followupBox.addEventListener('toggle', function () {
                    const chevron = this.querySelector('summary i.fa-chevron-down');
                    if (chevron) {
                        chevron.style.transform = this.open ? 'rotate(180deg)' : 'rotate(0deg)';
                    }
                });
            }
        })();
    </script>
</section>

            <!-- Collapsible speaker notes (visible only when NOT fullscreen) -->
            <!-- <div id="speaker-notes-container" aria-hidden="false">
                <div id="speaker-notes" class="speaker-notes collapsed" aria-live="polite">
                    <button id="notes-toggle" aria-expanded="false" aria-controls="notes-content">Show notes</button>
                    <div id="notes-content" class="notes-content" tabindex="0"></div>
                </div>
            </div> --><!-- changelog: rationale: Add missing nav-dots container so initNavigation() can append dots and avoid JS errors; source: presentation_inline.html lines 1798-1806 -->
            <div class="nav-container" id="nav-dots">
                <!-- Navigation dots will be generated by JS -->
            </div>
        </div>
    </div>

    <div class="nav-arrows">
        <div class="nav-arrow" id="prev-arrow" onclick="changeSlide(-1)" tabindex="0" aria-label="Previous slide">
            <i class="fas fa-chevron-left"></i>
        </div>
        <div class="nav-arrow" id="next-arrow" onclick="changeSlide(1)" tabindex="0" aria-label="Next slide">
            <i class="fas fa-chevron-right"></i>
        </div>
    </div>

    <div class="keyboard-hint" id="keyboard-hint">
        Use <kbd>←</kbd> <kbd>→</kbd> or <kbd>Space</kbd> to navigate
    </div>

    <!-- Presenter assets -->
    <link rel="stylesheet" href="assets/presenter.css">
    <script src="assets/presenter.js" defer></script>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide-container');
        const totalSlides = slides.length;
        // Logical mapping for grouped slides (computed in initNavigation)
        let slideToLogical = [];
        let logicalToFirst = [];
        let logicalCount = totalSlides;

        function initNavigation() {
            const navDots = document.getElementById('nav-dots');

            // Compute logical mapping: collapse consecutive slides with same data-group into one logical step
            slideToLogical = new Array(totalSlides);
            logicalToFirst = [];
            logicalCount = 0;
            for (let i = 0; i < totalSlides; i++) {
                const grp = slides[i] && slides[i].dataset ? slides[i].dataset.group : undefined;
                if (grp) {
                    // start of a new group?
                    if (i === 0 || !(slides[i - 1] && slides[i - 1].dataset && slides[i - 1].dataset.group === grp)) {
                        logicalToFirst.push(i);
                        slideToLogical[i] = logicalCount;
                        logicalCount++;
                    } else {
                        // same group as previous: assign same logical index
                        slideToLogical[i] = logicalCount - 1;
                    }
                } else {
                    // standalone slide
                    logicalToFirst.push(i);
                    slideToLogical[i] = logicalCount;
                    logicalCount++;
                }
            }
            for (let i = 0; i < totalSlides; i++) {
                const dot = document.createElement('div');
                dot.className = 'nav-dot' + (i === 0 ? ' active' : '');
                dot.onclick = () => goToSlide(i);
                dot.setAttribute('tabindex', '0');
                dot.setAttribute('aria-label', `Go to slide ${i + 1}`);
                navDots.appendChild(dot);

                // Stable IDs & accessibility for slide elements
                if (slides[i]) {
                    slides[i].dataset.nodeId = `slide-${i + 1}`;
                    slides[i].setAttribute('role', 'group');
                    slides[i].setAttribute('aria-roledescription', 'slide');
                    slides[i].setAttribute('aria-hidden', i === 0 ? 'false' : 'true');
                    const pb = slides[i].querySelector('.progress-bar');
                    if (pb) pb.dataset.elementId = `progress-${i + 1}`;
                    // override progress-bar width using logical mapping so annex groups count as one
                    if (pb) {
                        const logicalIdx = typeof slideToLogical[i] !== 'undefined' ? slideToLogical[i] : i;
                        const pct = Math.round(((logicalIdx + 1) / Math.max(1, logicalCount)) * 10000) / 100; // two decimals
                        pb.style.width = pct + '%';
                    }
                    // add slide counter badge with letters for multi-tab slides
                    let counter = slides[i].querySelector('.slide-counter');
                    const tabCount = slides[i].querySelectorAll('[role="tab"]').length;
                    // If slide has tabs, we'll add a letter indicator to the slide number
                    // The letter will be shown as the active tab changes
                    if (!counter) {
                        counter = document.createElement('div');
                        counter.className = 'slide-counter';
                        counter.dataset.slideIndex = i;
                        counter.dataset.tabCount = tabCount;
                        slides[i].appendChild(counter);
                    }
                    counter.dataset.slideIndex = i;
                    counter.dataset.tabCount = tabCount;
                    const logicalIdx = typeof slideToLogical[i] !== 'undefined' ? slideToLogical[i] : i;
                    // Set initial label — treat cover (index 0) as unnumbered
                    if (i === 0) {
                        counter.textContent = '';
                        counter.style.display = 'none';
                        counter.setAttribute('aria-hidden', 'true');
                    } else {
                        counter.style.display = '';
                        counter.setAttribute('aria-hidden', 'false');
                        // Display logical slide number (1-based logical ordering maps to visible labels)
                        const visibleNumber = logicalIdx + 1;
                        counter.textContent = `${visibleNumber}`;
                        counter.setAttribute('aria-label', `Slide ${visibleNumber}`);
                    }
                    // If this slide has tabs, set up listeners to update counter when tabs change
                    if (tabCount > 0) {
                        const tabs = slides[i].querySelectorAll('[role="tab"]');
                        tabs.forEach((tab, tabIdx) => {
                            // Watch for aria-selected attribute changes (handles both click and keyboard nav)
                            const observer = new MutationObserver(() => {
                                if (tab.getAttribute('aria-selected') === 'true' && i > 0) {
                                    const visibleNum = logicalIdx + 1;
                                    const letter = String.fromCharCode(97 + tabIdx);
                                    counter.textContent = `${visibleNum}${letter}`;
                                    counter.setAttribute('aria-label', `Slide ${visibleNum}${letter}`);
                                }
                            });
                            observer.observe(tab, { attributes: true, attributeFilter: ['aria-selected'] });
                        });
                        // Set initial active tab letter
                        const activeTab = slides[i].querySelector('[role="tab"][aria-selected="true"]');
                        if (activeTab && i > 0) {
                            const activeIdx = Array.from(tabs).indexOf(activeTab);
                            if (activeIdx >= 0) {
                                const visibleNum = logicalIdx + 1;
                                const letter = String.fromCharCode(97 + activeIdx);
                                counter.textContent = `${visibleNum}${letter}`;
                                counter.setAttribute('aria-label', `Slide ${visibleNum}${letter}`);
                            }
                        }
                    }
                }
            }
            updateSlideVisibility();

            // Populate overview sidebar
            const overviewList = document.getElementById('overview-list');
            if (overviewList) {
                overviewList.innerHTML = '';
                // hidden measurement container (offscreen but rendered) to compute sizes for slides that may be display:none
                const measurer = document.createElement('div');
                measurer.style.position = 'absolute';
                measurer.style.left = '-10000px';
                measurer.style.top = '0';
                measurer.style.width = 'auto';
                measurer.style.height = 'auto';
                measurer.style.overflow = 'visible';
                measurer.style.pointerEvents = 'none';
                measurer.style.visibility = 'hidden';
                document.body.appendChild(measurer);

                slides.forEach((slide, i) => {
                    const li = document.createElement('li');
                    li.setAttribute('role', 'button');
                    li.setAttribute('tabindex', '0');
                    const thumb = document.createElement('div');
                    thumb.className = 'ov-thumb';
                    const THUMB_W = 180, THUMB_H = 101;
                    // clone and sanitize
                    const clone = slide.cloneNode(true);
                    clone.querySelectorAll && clone.querySelectorAll('.progress-container, .slide-counter, .progress-zones, #presenter-overlay').forEach(el => el.remove());
                    clone.querySelectorAll && clone.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));
                    clone.querySelectorAll && clone.querySelectorAll('a,button,input,textarea').forEach(el => el.setAttribute('tabindex', '-1'));
                    clone.querySelectorAll && clone.querySelectorAll('[style]').forEach(el => { if (el.style && el.style.transform) el.style.transform = ''; });

                    // measure by appending to measurer so styles/layout apply even if original slide is display:none
                    measurer.appendChild(clone);
                    // force reflow
                    const rect = clone.getBoundingClientRect();
                    const oW = rect && rect.width ? rect.width : 1280;
                    const oH = rect && rect.height ? rect.height : 720;
                    // set measured size explicitly and compute scale to fit both dimensions
                    clone.style.boxSizing = 'border-box';
                    clone.style.width = oW + 'px';
                    clone.style.height = oH + 'px';
                    clone.style.margin = '0';
                    clone.style.pointerEvents = 'none';
                    clone.style.display = 'block';
                    const scale = Math.min(THUMB_W / oW, THUMB_H / oH);
                    // compute translation so scaled content is centered inside the thumbnail
                    const scaledW = oW * scale;
                    const scaledH = oH * scale;
                    const dx = Math.max(0, (scaledW - THUMB_W) / 2);
                    const dy = Math.max(0, (scaledH - THUMB_H) / 2);
                    const tx = -dx / scale;
                    const ty = -dy / scale;
                    clone.style.transformOrigin = 'top left';
                    clone.style.transform = 'translate(' + tx + 'px,' + ty + 'px) scale(' + scale + ')';
                    // move clone into thumbnail (removes from measurer)
                    thumb.appendChild(clone);

                    li.appendChild(thumb);
                    li.addEventListener('click', () => goToSlide(i));
                    li.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); goToSlide(i); } });
                    overviewList.appendChild(li);
                });

                // cleanup measurer
                measurer.remove();
            }

            // Make progress bars interactive: allow click-to-navigate and keyboard activation
            document.querySelectorAll('.progress-container').forEach((pc, idx) => {
                pc.setAttribute('tabindex', '0');
                pc.setAttribute('role', 'button');
                pc.setAttribute('aria-label', `Jump to slide`);
                pc.addEventListener('click', (e) => {
                    const rect = pc.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const frac = Math.max(0, Math.min(1, x / rect.width));
                    const logicalTarget = Math.round(frac * (logicalCount - 1));
                    const slideTarget = logicalToFirst[Math.max(0, Math.min(logicalCount - 1, logicalTarget))];
                    goToSlide(slideTarget);
                });
                pc.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); pc.click(); }
                });
            });

            // update active state in overview when slide changes
            function refreshOverviewActive() {
                const overviewList = document.getElementById('overview-list');
                if (!overviewList) return;
                overviewList.querySelectorAll('li').forEach((li, idx) => li.classList.toggle('active', idx === currentSlide));
            }
            // call once now and also when slide updates
            refreshOverviewActive();

            // Hover preview thumbnail for progress bar
            (function attachProgressPreview() {
                const PREVIEW_W = 320, PREVIEW_H = 180;
                const ORIGINAL_W = 1280, ORIGINAL_H = 720;
                const preview = document.createElement('div');
                preview.className = 'progress-preview';
                // ensure preview is appended to the current fullscreen root if present so it remains visible
                function getPreviewParent() { return document.fullscreenElement || document.body; }
                let previewParent = getPreviewParent();
                previewParent.appendChild(preview);

                // when fullscreen changes, reparent the preview into the fullscreen element (or back to body)
                document.addEventListener('fullscreenchange', () => {
                    const newParent = getPreviewParent();
                    if (newParent && preview.parentNode !== newParent) {
                        newParent.appendChild(preview);
                        previewParent = newParent;
                    }
                });

                // create per-slide visual zones overlay inside each progress container
                document.querySelectorAll('.progress-container').forEach(pc => {
                    // create zones wrapper (based on logical slide count so groups count as one)
                    const zones = document.createElement('div');
                    zones.className = 'progress-zones';
                    zones.style.pointerEvents = 'none';
                    const pct = 100 / logicalCount;
                    for (let i = 0; i < logicalCount; i++) {
                        const z = document.createElement('div');
                        z.className = 'zone';
                        z.style.left = (i * pct) + '%';
                        z.style.width = pct + '%';
                        zones.appendChild(z);
                    }
                    pc.appendChild(zones);
                    // highlight zone on mousemove
                    pc.addEventListener('mousemove', (e) => {
                        const rect = pc.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const frac = Math.max(0, Math.min(1, x / rect.width));
                        const logicalIdx = Math.floor(frac * logicalCount);
                        pc.querySelectorAll('.zone').forEach((zn, j) => zn.classList.toggle('active', j === logicalIdx));
                    });
                    pc.addEventListener('mouseleave', () => pc.querySelectorAll('.zone').forEach(zn => zn.classList.remove('active')));
                });

                function showPreviewAt(pc, clientX, clientY) {
                    const rect = pc.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const frac = Math.max(0, Math.min(1, x / rect.width));
                    const logicalIdx = Math.round(frac * (logicalCount - 1));
                    const idx = logicalToFirst[Math.max(0, Math.min(logicalCount - 1, logicalIdx))];
                    // position the preview above the cursor (use viewport coordinates)
                    preview.style.position = 'fixed';
                    preview.style.left = clientX + 'px';
                    preview.style.top = (rect.top) + 'px';

                    if (preview.dataset.idx == String(idx)) { preview.style.display = 'block'; return; }
                    preview.dataset.idx = String(idx);
                    preview.innerHTML = '';
                    const srcSlide = slides[idx];
                    if (!srcSlide) return;
                    const source = srcSlide.querySelector('.slide-inner') || srcSlide.cloneNode(true);
                    const thumb = source.cloneNode(true);
                    thumb.classList.add('thumb');
                    // reset ids/interactive attributes to avoid duplicate ids or focusable controls
                    thumb.querySelectorAll && thumb.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));
                    thumb.querySelectorAll && thumb.querySelectorAll('a,button,input,textarea').forEach(el => el.setAttribute('tabindex', '-1'));

                    // scale to preview size
                    const scale = PREVIEW_W / ORIGINAL_W;
                    thumb.style.transform = 'scale(' + scale + ')';
                    thumb.style.transformOrigin = 'top left';
                    thumb.style.width = ORIGINAL_W + 'px';
                    thumb.style.height = ORIGINAL_H + 'px';
                    preview.appendChild(thumb);
                    preview.style.display = 'block';
                }

                function hidePreview() { preview.style.display = 'none'; preview.dataset.idx = ''; }

                document.querySelectorAll('.progress-container').forEach(pc => {
                    pc.addEventListener('mousemove', (e) => showPreviewAt(pc, e.clientX, e.clientY));
                    pc.addEventListener('mouseenter', (e) => showPreviewAt(pc, e.clientX, e.clientY));
                    pc.addEventListener('mouseleave', () => hidePreview());
                    // support touch: show at touch position briefly
                    pc.addEventListener('touchstart', (e) => {
                        if (!e.touches || e.touches.length === 0) return;
                        const t = e.touches[0]; showPreviewAt(pc, t.clientX, t.clientY);
                    });
                });
            })();

            // Show keyboard hint briefly on load
            setTimeout(() => {
                const hint = document.getElementById('keyboard-hint');
                hint.classList.add('visible');
                setTimeout(() => hint.classList.remove('visible'), 3000);
            }, 1000);
        }

        function updateSlideVisibility() {
            slides.forEach((slide, index) => {
                if (index === currentSlide) {
                    slide.style.display = 'block';
                    slide.style.animation = 'none';
                    slide.offsetHeight; // Trigger reflow
                    // Check if this is a roadmap slide (has .stage element for morph-like transition)
                    const isRoadmapSlide = slide.querySelector('.stage') !== null;
                    if (!isRoadmapSlide) {
                        slide.style.animation = 'slideIn 0.4s ease-out';
                    }
                    slide.setAttribute('aria-hidden', 'false');
                } else {
                    slide.style.display = 'none';
                    slide.setAttribute('aria-hidden', 'true');
                }
            });

            document.querySelectorAll('.nav-dot').forEach((dot, index) => {
                dot.classList.toggle('active', index === currentSlide);
            });

            document.getElementById('prev-arrow').classList.toggle('hidden', currentSlide === 0);
            document.getElementById('next-arrow').classList.toggle('hidden', currentSlide === totalSlides - 1);

            // Notify presenter of slide change
            if (window.Presenter && typeof window.Presenter.sendUpdate === 'function') {
                window.Presenter.sendUpdate(currentSlide);
            } else if (window.PresenterLocal) {
                window.PresenterLocal.sendUpdate(currentSlide);
            }
            // refresh overview active highlight
            const ov = document.getElementById('overview-list');
            if (ov) ov.querySelectorAll('li').forEach((li, idx) => li.classList.toggle('active', idx === currentSlide));
        }

        function changeSlide(direction) {
            currentSlide = Math.max(0, Math.min(totalSlides - 1, currentSlide + direction));
            updateSlideVisibility();
        }

        function goToSlide(index) {
            currentSlide = index;
            updateSlideVisibility();
        }

        // Keyboard navigation (enhanced)
        // support multi-digit slide entry like Reveal.js (type digits quickly, commit on timeout or Enter)
        let _numericBuffer = '';
        let _numericTimer = null;
        const _numericTimeout = 200; // ms to wait for additional digits (reduced from 1000 to 200)

        function _commitNumericBuffer() {
            if (!_numericBuffer) return;
            const n = parseInt(_numericBuffer, 10);
            _numericBuffer = '';
            if (_numericTimer) { clearTimeout(_numericTimer); _numericTimer = null; }
            if (Number.isNaN(n)) return;

            // Prefer mapping the numeric shortcut to the visible slide counter
            // (handles presentations where slide indices and visible labels diverge).
            // Map numeric entry to logical slide numbers (group-collapsed)
            const targetNum = Math.max(1, Math.min(logicalCount || totalSlides, n));
            for (let i = 0; i < slides.length; i++) {
                const s = slides[i];
                if (!s) continue;
                const counter = s.querySelector('.slide-counter');
                if (!counter) continue;
                // aria-label like "Slide 4" or plain text '4'
                const label = (counter.getAttribute('aria-label') || counter.textContent || '').trim();
                const digits = (label.match(/\d+/) || [])[0];
                if (digits && parseInt(digits, 10) === targetNum) {
                    goToSlide(i);
                    return;
                }
            }

            // Fallback: map logical number to first physical slide of that logical group
            const physical = (logicalToFirst && logicalToFirst[targetNum - 1]) || (targetNum - 1);
            goToSlide(physical);
        }

        document.addEventListener('keydown', (e) => {
            // ignore when typing in input/textarea
            const tgt = e.target && (e.target.tagName || '').toLowerCase();
            if (tgt === 'input' || tgt === 'textarea' || e.metaKey || e.ctrlKey || e.altKey) return;

            if (e.key === 'ArrowDown') {
                // prefer vertical navigation within a grouped annex
                e.preventDefault();
                if (slides[currentSlide] && slides[currentSlide + 1] && slides[currentSlide].dataset.group && slides[currentSlide + 1].dataset.group === slides[currentSlide].dataset.group) {
                    goToSlide(currentSlide + 1);
                } else {
                    changeSlide(1);
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (slides[currentSlide] && slides[currentSlide - 1] && slides[currentSlide].dataset.group && slides[currentSlide - 1].dataset.group === slides[currentSlide].dataset.group) {
                    goToSlide(currentSlide - 1);
                } else {
                    changeSlide(-1);
                }
            } else if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                changeSlide(1);
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                // If currently inside an annex group, Left should exit the annexes
                const cur = slides[currentSlide];
                if (cur && cur.dataset && cur.dataset.group) {
                    const groupName = cur.dataset.group;
                    // find first index of this group
                    let firstIdx = -1;
                    for (let i = 0; i < slides.length; i++) {
                        if (slides[i] && slides[i].dataset && slides[i].dataset.group === groupName) { firstIdx = i; break; }
                    }
                    if (firstIdx !== -1) {
                        const before = Math.max(0, firstIdx - 1);
                        goToSlide(before);
                        return;
                    }
                }
                changeSlide(-1);
            } else if (e.key === 'Home') {
                e.preventDefault();
                goToSlide(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                goToSlide(totalSlides - 1);
            } else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                toggleFullscreen();
            } else if (e.key === 'p' || e.key === 'P') {
                // toggle presenter view
                if (window.Presenter && typeof window.Presenter.toggle === 'function') window.Presenter.toggle();
                else if (window.PresenterLocal) window.PresenterLocal.toggle();
            } else if (e.key === 'Escape') {
                // Escape: exit fullscreen if present, otherwise toggle overview visibility
                e.preventDefault();
                if (document.fullscreenElement) {
                    if (document.exitFullscreen) document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                } else {
                    const ov = document.getElementById('overview-sidebar');
                    if (ov) ov.style.display = (ov.style.display === 'none' ? '' : 'none');
                }
            } else if (e.key === 'Enter') {
                // confirm numeric entry if present
                if (_numericBuffer) { e.preventDefault(); _commitNumericBuffer(); }
            } else if (e.key === 'Backspace') {
                if (_numericBuffer) { e.preventDefault(); _numericBuffer = _numericBuffer.slice(0, -1); }
            } else if (/^\d$/.test(e.key)) {
                // Number keys: accumulate digits for multi-digit slide selection
                e.preventDefault();
                _numericBuffer += e.key;
                // reset timer
                if (_numericTimer) clearTimeout(_numericTimer);
                _numericTimer = setTimeout(() => { _commitNumericBuffer(); }, _numericTimeout);
            }
        });

        // Enter key support for navigation elements
        document.querySelectorAll('.nav-arrow').forEach(el => {
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    el.click();
                }
            });
        });

        // Presenter local adapter for this inline presentation (fallback if presenter.js not used)
        window.PresenterLocal = (function () {
            let wnd = null;
            let overlay = null;
            function getSlidesData() {
                return Array.from(slides).map((el, i) => {
                    const titleEl = el.querySelector('h1,h2,h3');
                    const title = titleEl ? titleEl.textContent.trim() : `Slide ${i + 1}`;
                    // attempt to find notes (not present by default)
                    const noteEl = el.querySelector('.notes, aside.notes');
                    const notes = noteEl ? noteEl.innerHTML : '';
                    return { index: i, title, notes };
                });
            }
            function openWindow() {
                try {
                    wnd = window.open('/phd_confirmation_slides/presenter.html', 'presenter_window', 'width=900,height=700');
                    if (!wnd) return false;
                    setTimeout(() => sendState(), 300);
                    return true;
                } catch (e) {
                    console.warn('[presenter] openWindow failed', e);
                    return false;
                }
            }
            function closeWindow() { if (wnd && !wnd.closed) wnd.close(); wnd = null; }
            function sendState() {
                const payload = { type: 'state', slides: getSlidesData(), index: currentSlide };
                if (wnd && !wnd.closed) wnd.postMessage(payload, '*');
                if (overlay) renderOverlay(payload);
            }
            function sendUpdate(index) {
                const payload = { type: 'update', slides: getSlidesData(), index };
                if (wnd && !wnd.closed) wnd.postMessage(payload, '*');
                if (overlay) renderOverlay(payload);
            }
            function enterOverlay() {
                if (overlay) return;
                overlay = document.createElement('div');
                overlay.id = 'presenter-overlay';
                overlay.innerHTML = `
                  <div class="pane">
                    <div class="controls"><button id="pr-prev">Prev</button><button id="pr-next">Next</button><button id="pr-close">Close</button></div>
                    <div class="preview"><div id="pr-current-title" class="presenter-title"></div><div id="pr-current-notes" class="notes"></div></div>
                  </div>
                  <div class="pane"><div class="preview"><div id="pr-next-title" class="presenter-title"></div><div id="pr-next-notes" class="notes"></div></div></div>
                `;
                document.body.appendChild(overlay);
                document.getElementById('pr-next').addEventListener('click', () => changeSlide(1));
                document.getElementById('pr-prev').addEventListener('click', () => changeSlide(-1));
                document.getElementById('pr-close').addEventListener('click', () => exitOverlay());
                sendState();
            }
            function exitOverlay() { if (!overlay) return; overlay.remove(); overlay = null; }
            function renderOverlay(payload) {
                const { slides: sld, index } = payload;
                const cur = sld[index] || { title: '', notes: '' };
                const next = sld[index + 1] || { title: '', notes: '' };
                const elTitle = document.getElementById('pr-current-title');
                const elNotes = document.getElementById('pr-current-notes');
                const elNextTitle = document.getElementById('pr-next-title');
                const elNextNotes = document.getElementById('pr-next-notes');
                if (elTitle) elTitle.textContent = cur.title || '';
                if (elNotes) elNotes.innerHTML = cur.notes || '';
                if (elNextTitle) elNextTitle.textContent = next.title || '';
                if (elNextNotes) elNextNotes.innerHTML = next.notes || '';
            }
            function toggle() {
                if (wnd && !wnd.closed) { closeWindow(); exitOverlay(); return; }
                const ok = openWindow(); if (!ok) enterOverlay();
            }
            return { toggle, sendUpdate, sendState, openWindow, closeWindow, enterOverlay, exitOverlay };
        })();

        // small presenter & layout buttons
        (function attachPresenterButton() {
            // Fullscreen toggle button
            const fs = document.createElement('button');
            fs.id = 'fullscreen-toggle';
            fs.setAttribute('aria-label', 'Toggle fullscreen (F)');
            fs.title = 'Toggle fullscreen (F)';
            fs.innerHTML = '<i class="fas fa-expand"></i>';
            fs.addEventListener('click', () => toggleFullscreen());
            document.body.appendChild(fs);

            // layout edit toggle
            const layoutBtn = document.createElement('button');
            layoutBtn.id = 'layout-toggle';
            layoutBtn.className = 'presenter-btn';
            layoutBtn.setAttribute('aria-pressed', 'false');
            layoutBtn.setAttribute('aria-label', 'Toggle layout edit mode');
            layoutBtn.title = 'Toggle layout edit mode (drag/resize)';
            layoutBtn.textContent = '✎';
            layoutBtn.style.marginLeft = '8px';
            layoutBtn.addEventListener('click', function (ev) {
                ev.preventDefault();
                const enabled = document.body.classList.toggle('edit-mode');
                layoutBtn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
                if (enabled) enableEditMode(); else disableEditMode();
            });
            document.body.appendChild(layoutBtn);

            // small edit toolbar
            const toolbar = document.createElement('div');
            toolbar.className = 'edit-toolbar';
            toolbar.innerHTML = '<strong>Edit mode</strong> &nbsp; <button id="edit-reset">Reset</button>';
            document.body.appendChild(toolbar);
            toolbar.querySelector('#edit-reset').addEventListener('click', function () { if (confirm('Reset layout overrides?')) { localStorage.removeItem('presentation_layout_overrides'); applySavedOverrides(); } });
        })();

        // Fullscreen helpers
        function toggleFullscreen() {
            const el = document.querySelector('.slide-wrapper') || document.documentElement;
            if (!document.fullscreenElement) {
                if (el.requestFullscreen) el.requestFullscreen();
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        // Wrap slide contents in a .slide-inner so we can scale content independently
        (function wrapSlides() {
            const ORIGINAL_W = 1280;
            const ORIGINAL_H = 720;
            document.querySelectorAll('.slide-container').forEach(slide => {
                if (slide.querySelector('.slide-inner')) return;
                const progress = slide.querySelector('.progress-container');
                const inner = document.createElement('div');
                inner.className = 'slide-inner';
                // move all children except progress into inner
                Array.from(slide.childNodes).forEach(node => {
                    if (node === progress) return;
                    inner.appendChild(node);
                });
                slide.appendChild(inner);
                if (progress) slide.appendChild(progress);
                // set default sizes
                inner.style.width = ORIGINAL_W + 'px';
                inner.style.height = ORIGINAL_H + 'px';
                inner.style.transformOrigin = 'top left';
                // ensure a notes container exists for speaker notes
                if (!slide.querySelector('.notes') && !slide.querySelector('aside.notes')) {
                    const notes = document.createElement('aside');
                    notes.className = 'notes';
                    notes.setAttribute('aria-label', 'Speaker notes');
                    notes.style.display = 'none';
                    slide.appendChild(notes);
                }
            });
        })();

        // Speaker notes: populate and toggle
        (function speakerNotes() {
            const notesToggle = document.getElementById('notes-toggle');
            const notesContent = document.getElementById('notes-content');
            const notesBox = document.querySelector('.speaker-notes');
            if (!notesToggle || !notesContent || !notesBox) {
                // nothing to do if notes UI not present
            } else {
                function updateNotes() {
                    const slide = slides[currentSlide];
                    if (!slide) { notesContent.innerHTML = ''; return; }
                    const noteEl = slide.querySelector('.notes, aside.notes');
                    if (noteEl) notesContent.innerHTML = noteEl.innerHTML; else notesContent.innerHTML = '';
                }

                // Position and size the notes pane so it always fits inside the slide-wrapper.
                function positionNotes() {
                    const notesContainer = document.getElementById('speaker-notes-container');
                    const notesBox = document.querySelector('.speaker-notes');
                    if (!notesContainer || !notesBox) return;
                    const slide = slides[currentSlide];
                    const wrapper = document.querySelector('.slide-wrapper') || document.documentElement;
                    if (!slide) {
                        notesContainer.style.top = '';
                        notesContainer.style.bottom = '';
                        notesContainer.classList.remove('flipped');
                        notesBox.style.maxHeight = '';
                        return;
                    }
                    const gap = 12; // small spacing between slide and notes
                    const slideRect = slide.getBoundingClientRect();
                    const wrapRect = wrapper.getBoundingClientRect();
                    const availableBelow = Math.max(0, wrapRect.bottom - slideRect.bottom - gap);
                    const availableAbove = Math.max(0, slideRect.top - wrapRect.top - gap);

                    if (!notesBox.classList.contains('collapsed')) {
                        // Prefer placing below unless there's clearly more space above.
                        if (availableBelow >= Math.max(160, availableAbove)) {
                            notesContainer.classList.remove('flipped');
                            const topPx = Math.round(slideRect.bottom - wrapRect.top + gap);
                            notesContainer.style.top = topPx + 'px';
                            notesContainer.style.bottom = '';
                            notesBox.style.maxHeight = Math.max(56, availableBelow - 24) + 'px';
                        } else {
                            // Place above the slide if that fits better.
                            notesContainer.classList.add('flipped');
                            notesContainer.style.bottom = Math.round(wrapRect.bottom - slideRect.top + gap) + 'px';
                            notesContainer.style.top = '';
                            notesBox.style.maxHeight = Math.max(56, availableAbove - 24) + 'px';
                        }
                    } else {
                        // Collapsed: reset inline sizing/position so CSS default applies.
                        notesContainer.classList.remove('flipped');
                        notesContainer.style.top = '';
                        notesContainer.style.bottom = '';
                        notesBox.style.maxHeight = '';
                    }
                }

                function setCollapsed(collapsed) {
                    if (collapsed) {
                        notesBox.classList.add('collapsed');
                        notesToggle.textContent = 'Show notes';
                        notesToggle.setAttribute('aria-expanded', 'false');
                    } else {
                        notesBox.classList.remove('collapsed');
                        notesToggle.textContent = 'Hide notes';
                        notesToggle.setAttribute('aria-expanded', 'true');
                    }
                    try { localStorage.setItem('speaker_notes_collapsed', collapsed ? '1' : '0'); } catch (e) { }
                    // Recompute position after collapsing/expanding.
                    positionNotes();
                }

                notesToggle.addEventListener('click', () => { setCollapsed(!notesBox.classList.contains('collapsed')); positionNotes(); });
                notesToggle.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); notesToggle.click(); } });
                const stored = (function () { try { return localStorage.getItem('speaker_notes_collapsed'); } catch (e) { return null; } })();
                setCollapsed(stored === null ? true : stored === '1');
                const origUpdate = updateSlideVisibility;
                updateSlideVisibility = function () { origUpdate(); updateNotes(); positionNotes(); };
                updateNotes();
                // ensure notes are positioned on load and when viewport changes
                positionNotes();
                window.addEventListener('resize', positionNotes);
                window.addEventListener('scroll', positionNotes, true);
            }
        })();

        // Enhanced fullscreen handler: scale slide contents so they zoom to fit viewport
        (function setupFullscreenScaling() {
            const ORIGINAL_W = 1280;
            const ORIGINAL_H = 720;

            function applyScale(isFs) {
                document.querySelectorAll('.slide-container').forEach(slide => {
                    const inner = slide.querySelector('.slide-inner');
                    if (!inner) return;
                    if (isFs) {
                        const scale = Math.min(window.innerWidth / ORIGINAL_W, window.innerHeight / ORIGINAL_H);
                        // set slide container box to the scaled visual size so centering works
                        slide.style.width = Math.round(ORIGINAL_W * scale) + 'px';
                        slide.style.height = Math.round(ORIGINAL_H * scale) + 'px';
                        slide.style.overflow = 'hidden';
                        // scale the inner content
                        inner.style.transform = 'scale(' + scale + ')';
                    } else {
                        // clear inline styles to return to CSS defaults
                        slide.style.width = '';
                        slide.style.height = '';
                        slide.style.overflow = '';
                        inner.style.transform = '';
                    }
                });
            }

            document.addEventListener('fullscreenchange', () => {
                const fsBtn = document.getElementById('fullscreen-toggle');
                const isFs = !!document.fullscreenElement;
                document.body.classList.toggle('fullscreen-lock', isFs);
                if (fsBtn) fsBtn.innerHTML = isFs ? '<i class="fas fa-compress"></i>' : '<i class="fas fa-expand"></i>';
                applyScale(isFs);
                // hide/show speaker notes container explicitly to avoid layout and rendering issues
                try {
                    const notesContainer = document.getElementById('speaker-notes-container');
                    if (notesContainer) notesContainer.style.display = isFs ? 'none' : '';
                } catch (e) { /* ignore */ }
            });

            // Recompute on resize while in fullscreen
            window.addEventListener('resize', () => {
                if (document.fullscreenElement) applyScale(true);
            });
        })();

        // Dynamic logo loader: replace the placeholder icon in .ucl-logo with inline SVG(s).
        // Usage: add a data-logos attribute (comma-separated paths) on any .ucl-logo element,
        // e.g. <div class="ucl-logo" data-logos="assets/logos/ucl.svg,assets/logos/ucl-small.svg">...
        async function loadLogos() {
            document.querySelectorAll('.ucl-logo[data-logos]').forEach(async (el) => {
                const raw = el.getAttribute('data-logos') || '';
                const list = raw.split(',').map(s => s.trim()).filter(Boolean);
                if (!list.length) return;

                // remove existing placeholder icon if present
                const placeholder = el.querySelector('i.fa-university');
                if (placeholder) placeholder.remove();

                // create svg container
                let svgWrap = el.querySelector('.logo-svg');
                if (!svgWrap) {
                    svgWrap = document.createElement('div');
                    svgWrap.className = 'logo-svg';
                    svgWrap.setAttribute('aria-hidden', 'false');
                    svgWrap.style.display = 'inline-flex';
                    svgWrap.style.alignItems = 'center';
                    svgWrap.style.marginRight = '8px';
                    el.insertBefore(svgWrap, el.firstChild);
                }

                async function setLogo(idx) {
                    const src = list[idx % list.length];
                    try {
                        const res = await fetch(src);
                        if (!res.ok) throw new Error('fetch failed');
                        const text = await res.text();
                        // inline the svg so it inherits CSS and is accessible
                        svgWrap.innerHTML = text;
                        // mark current index
                        svgWrap.dataset.logoIndex = String(idx);
                    } catch (err) {
                        // fallback: show the text label if fetch fails
                        svgWrap.textContent = el.getAttribute('data-logo-alt') || 'Logo';
                    }
                }

                // if multiple logos, add a small switcher control
                if (list.length > 1) {
                    let switcher = el.querySelector('.logo-switcher');
                    if (!switcher) {
                        switcher = document.createElement('div');
                        switcher.className = 'logo-switcher';
                        switcher.style.display = 'inline-flex';
                        switcher.style.gap = '6px';
                        switcher.style.marginLeft = '8px';
                        el.appendChild(switcher);
                    }
                    list.forEach((s, idx) => {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'logo-switch';
                        btn.title = `Logo ${idx + 1}`;
                        btn.style.width = '12px';
                        btn.style.height = '12px';
                        btn.style.borderRadius = '50%';
                        btn.style.border = '1px solid rgba(0,0,0,0.15)';
                        btn.style.background = idx === 0 ? '#003366' : '#E0E0E0';
                        btn.addEventListener('click', () => {
                            setLogo(idx);
                            // update visuals
                            switcher.querySelectorAll('button').forEach((b, j) => b.style.background = j === idx ? '#003366' : '#E0E0E0');
                        });
                        switcher.appendChild(btn);
                    });
                }

                // load first logo
                setLogo(0);
            });
        }

        // call loader once DOM is ready
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', loadLogos); else loadLogos();

        // Auto-wrap suitable images into zoomable figures (respects data-zoomable="false")
        function autoWrapZoomableImages() {
            const imgs = Array.from(document.querySelectorAll('img[src]'));
            imgs.forEach(img => {
                const src = img.getAttribute('src') || '';
                // skip roadmap asset explicitly
                if (/roadmap\.svg(?:[?#]|$)/i.test(src)) return;
                if (!/\.(jpe?g|png|svg)(?:[?#]|$)/i.test(src)) return;
                // if inside figure, enhance that figure instead of wrapping
                const existingFig = img.closest('figure');
                if (existingFig) {
                    // respect explicit opt-out
                    if (existingFig.closest && existingFig.closest('[data-zoomable="false"]')) return;
                    if (existingFig.getAttribute('data-zoomable') === 'false') return;
                    // add role and classes/attributes if missing
                    if (!existingFig.classList.contains('method-visual')) existingFig.classList.add('method-visual');
                    if (!existingFig.hasAttribute('data-zoomable')) existingFig.setAttribute('data-zoomable', 'true');
                    if (!existingFig.getAttribute('aria-label')) {
                        const aria = img.getAttribute('alt') ? img.getAttribute('alt') : src.split('/').pop();
                        existingFig.setAttribute('aria-label', aria);
                    }
                    // ensure figcaption contains zoom hint
                    let figcap = existingFig.querySelector('figcaption');
                    if (!figcap) {
                        const newcap = document.createElement('figcaption');
                        newcap.style.fontSize = '11px'; newcap.style.color = '#666'; newcap.style.marginTop = '6px';
                        if (img.getAttribute('alt')) { newcap.textContent = img.getAttribute('alt'); }
                        existingFig.appendChild(newcap);
                    }
                    if (!img.hasAttribute('loading')) img.setAttribute('loading', 'lazy');
                    return;
                }

                // skip if any ancestor opts out
                if (img.closest && img.closest('[data-zoomable="false"]')) return;

                const s = (src + ' ' + (img.getAttribute('alt') || '')).toLowerCase();
                if (/thumb|thumbnail|icon|logo|badge|small/.test(s)) return;
                const wAttr = img.getAttribute('width'); const hAttr = img.getAttribute('height');
                if ((wAttr && Number(wAttr) < 120) || (hAttr && Number(hAttr) < 120)) return;
                const rect = img.getBoundingClientRect();
                if ((rect.width && rect.width < 120) || (rect.height && rect.height < 120)) return;

                // Prefer wrapping the crop container if present so we preserve object-fit behavior
                const crop = img.closest('.crop-bottom');
                const targetToWrap = crop || img;

                const fig = document.createElement('figure');
                fig.className = 'method-visual';
                fig.setAttribute('data-zoomable', 'true');
                const aria = img.getAttribute('alt') ? img.getAttribute('alt') : src.split('/').pop();
                fig.setAttribute('aria-label', aria);
                fig.style.margin = '0'; fig.style.display = 'inline-block';

                targetToWrap.parentNode.insertBefore(fig, targetToWrap);
                fig.appendChild(targetToWrap);

                const figcap = document.createElement('figcaption');
                figcap.style.fontSize = '11px'; figcap.style.color = '#666'; figcap.style.marginTop = '6px';
                if (img.getAttribute('alt')) {
                    figcap.textContent = img.getAttribute('alt');
                    const hint = document.createElement('div'); hint.className = 'zoom-hint';
                }
                fig.appendChild(figcap);
                if (!img.hasAttribute('loading')) img.setAttribute('loading', 'lazy');
            });
        }
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', autoWrapZoomableImages); else autoWrapZoomableImages();

        // Global zoom helper: enables Ctrl/Meta+Click (and Enter/Space) to open a zoom modal
        function initZoomableComponents() {
            console.log('[zoom] initZoomableComponents called');
            // Inject minimal styles for zoom overlay and method grid behavior
            const css = `
            /* Zoomable visuals */
            .method-visual[data-zoomable="true"] { cursor: zoom-in; }
            .methods-grid { display: grid; grid-template-columns: 1fr 1fr; gap:12px; align-items: start; }
            @media (max-width: 1480px) { .methods-grid { grid-template-columns: 1fr; } }

            /* Zoom overlay */
            .zoom-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 9999; }
            .zoom-content { background: #fff; border-radius: 8px; padding: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); position: relative; display: flex; flex-direction: column; height: 90vh; width: 90vw; }
            .zoom-body { flex: 1; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; min-width: 0; }
            .zoom-body > img, .zoom-body > figure { max-width: 100%; max-height: 100%; object-fit: contain; display: block; margin: auto; }
            .zoom-image-wrapper { width: 100%; height: 100%; overflow: auto; display: flex; align-items: center; justify-content: center; cursor: grab; }
            .zoom-image-wrapper.panning { cursor: grabbing; }
            .zoom-image-wrapper img { cursor: zoom-in; max-width: none; max-height: none; user-select: none; }
            .zoom-image-wrapper.zoomed img { cursor: zoom-out; }
            .zoom-caption { font-size: 12px; color: #333; margin-top: 8px; padding: 0 4px; }
            .zoom-close { position: absolute; right: 8px; top: 8px; background: rgba(255,255,255,0.9); border: 1px solid #ddd; font-size: 18px; cursor: pointer; color: #333; width: 32px; height: 32px; border-radius: 4px; padding: 0; display: flex; align-items: center; justify-content: center; }
            .zoom-controls { display: flex; gap: 8px; align-items: center; justify-content: center; padding: 8px 0; font-size: 12px; color: #666; border-top: 1px solid #eee; }
            .zoom-controls button { padding: 4px 12px; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 12px; }
            .zoom-controls button:hover { background: #e0e0e0; }
            .zoom-controls button:disabled { opacity: 0.5; cursor: not-allowed; }
            .zoom-level-display { min-width: 60px; text-align: center; }
            @media (prefers-reduced-motion: reduce) { .zoom-content { transition: none !important; } }
            `;
            const styleEl = document.createElement('style'); styleEl.textContent = css; document.head.appendChild(styleEl);

            // Create overlay element once
            let overlay = document.getElementById('zoom-overlay');
            if (!overlay) {
                overlay = document.createElement('div'); overlay.id = 'zoom-overlay'; overlay.className = 'zoom-overlay';
                overlay.innerHTML = `
                    <div class="zoom-content" role="dialog" aria-modal="true" aria-labelledby="zoom-title">
                        <button class="zoom-close" aria-label="Close zoom">✕</button>
                        <div class="zoom-body" tabindex="-1"></div>
                        <div class="zoom-caption" id="zoom-caption"></div>
                        <div class="zoom-controls">
                            <button class="zoom-in-btn" aria-label="Zoom in" title="Zoom in (scroll or +)">🔍+</button>
                            <button class="zoom-out-btn" aria-label="Zoom out" title="Zoom out (scroll or -)">🔍−</button>
                            <button class="zoom-reset-btn" aria-label="Reset zoom" title="Reset zoom (R)">Reset</button>
                            <div class="zoom-level-display"><span id="zoom-level">100%</span></div>
                        </div>
                    </div>`;
                document.body.appendChild(overlay);
            }

            const zoomBody = overlay.querySelector('.zoom-body');
            const zoomCaption = overlay.querySelector('#zoom-caption');
            const zoomClose = overlay.querySelector('.zoom-close');
            const zoomInBtn = overlay.querySelector('.zoom-in-btn');
            const zoomOutBtn = overlay.querySelector('.zoom-out-btn');
            const zoomResetBtn = overlay.querySelector('.zoom-reset-btn');
            const zoomLevelDisplay = overlay.querySelector('#zoom-level');
            let lastActive = null;
            let currentZoomLevel = 1;
            let zoomImage = null;
            let startX = 0, startY = 0, scrollLeft = 0, scrollTop = 0, isMouseDown = false;

            function openZoomForElement(el) {
                console.log('[zoom] openZoomForElement', el);
                if (!el) return;
                lastActive = document.activeElement;
                currentZoomLevel = 1;
                // Detect interactive iframe targets and prefer creating a live iframe inside the overlay
                const iframeTarget = (el.tagName === 'IFRAME') ? el : el.querySelector && el.querySelector('iframe');
                if (iframeTarget && iframeTarget.src) {
                    lastActive = document.activeElement;
                    currentZoomLevel = 1;
                    zoomBody.innerHTML = '';

                    const wrapper = document.createElement('div');
                    wrapper.style.width = '100%'; wrapper.style.height = '100%'; wrapper.style.display = 'flex';
                    wrapper.style.alignItems = 'stretch'; wrapper.style.justifyContent = 'stretch';

                    const live = document.createElement('iframe');
                    live.src = iframeTarget.src;
                    live.title = iframeTarget.title || iframeTarget.getAttribute('aria-label') || 'Embedded content';
                    if (iframeTarget.getAttribute('sandbox')) live.setAttribute('sandbox', iframeTarget.getAttribute('sandbox'));
                    live.setAttribute('allowfullscreen', '');
                    live.style.width = '100%'; live.style.height = '100%'; live.style.border = '0';
                    live.tabIndex = 0;

                    wrapper.appendChild(live);
                    zoomBody.appendChild(wrapper);

                    zoomImage = null;

                    // caption: prefer figcaption or data-caption attribute
                    let caption = '';
                    const fig = el.closest && el.closest('figure');
                    if (fig) {
                        const figcap = fig.querySelector('figcaption'); if (figcap) caption = figcap.textContent.trim();
                    }
                    if (!caption && el.dataset && el.dataset.caption) caption = el.dataset.caption;
                    zoomCaption.textContent = caption || '';

                    // show overlay — ensure it's appended to the fullscreen element if present so it is visible
                    const container = document.fullscreenElement || document.body;
                    if (overlay.parentElement !== container) container.appendChild(overlay);
                    overlay.style.position = container === document.body ? 'fixed' : 'absolute';
                    overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.right = '0'; overlay.style.bottom = '0';
                    overlay.style.display = 'flex';
                    document.body.style.overflow = 'hidden';

                    // focus management: focus the iframe if possible
                    setTimeout(() => { try { live.focus(); } catch (e) { } }, 50);

                    // trap focus
                    trapFocus(overlay);

                    // Keep overlay visible if fullscreen changes while open
                    function _fsHandler() {
                        const newContainer = document.fullscreenElement || document.body;
                        if (overlay.parentElement !== newContainer) newContainer.appendChild(overlay);
                        overlay.style.position = newContainer === document.body ? 'fixed' : 'absolute';
                    }
                    document.addEventListener('fullscreenchange', _fsHandler);
                    overlay._fsHandler = _fsHandler;

                    return;
                }

                // Clone and sanitize
                const clone = el.cloneNode(true);
                // Remove zoomable attributes in clone
                clone.querySelectorAll('[data-zoomable]').forEach(n => n.removeAttribute('data-zoomable'));
                // Make interactive descendants inert
                clone.querySelectorAll('a,button,input,textarea,select,iframe').forEach(n => { n.setAttribute('tabindex', '-1'); n.setAttribute('aria-hidden', 'true'); });
                // Remove id attributes from clone to avoid duplicate ids
                clone.querySelectorAll('[id]').forEach(n => n.removeAttribute('id'));

                // set content
                zoomBody.innerHTML = '';

                // If clone contains a cropped image container, replace it with a full-sized image for the modal
                const cropped = clone.querySelector('.crop-bottom');
                if (cropped) {
                    const innerImg = cropped.querySelector('img');
                    if (innerImg && innerImg.src) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'zoom-image-wrapper';
                        const full = document.createElement('img');
                        full.src = innerImg.src;
                        full.alt = innerImg.alt || '';
                        wrapper.appendChild(full);
                        zoomBody.appendChild(wrapper);
                        zoomImage = full;
                        setupZoomInteractions(wrapper, full);
                    } else {
                        zoomBody.appendChild(clone);
                    }
                } else {
                    // Check if clone contains an image element
                    const img = clone.querySelector('img');
                    if (img) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'zoom-image-wrapper';
                        // Move the image into the wrapper or replace figure with wrapper
                        if (clone.tagName === 'FIGURE') {
                            // Extract just the image from figure
                            const figure = clone;
                            const figImg = figure.querySelector('img');
                            if (figImg) {
                                wrapper.appendChild(figImg.cloneNode(true));
                                zoomBody.appendChild(wrapper);
                                zoomImage = wrapper.querySelector('img');
                                setupZoomInteractions(wrapper, zoomImage);
                            } else {
                                zoomBody.appendChild(clone);
                            }
                        } else {
                            wrapper.appendChild(img.cloneNode(true));
                            zoomBody.appendChild(wrapper);
                            zoomImage = wrapper.querySelector('img');
                            setupZoomInteractions(wrapper, zoomImage);
                        }
                    } else {
                        zoomBody.appendChild(clone);
                    }
                }

                // caption: prefer figcaption or data-caption attribute
                let caption = '';
                const fig = el.closest('figure');
                if (fig) {
                    const figcap = fig.querySelector('figcaption'); if (figcap) caption = figcap.textContent.trim();
                }
                if (!caption && el.dataset && el.dataset.caption) caption = el.dataset.caption;
                zoomCaption.textContent = caption || '';

                // show overlay — ensure it's appended to the fullscreen element if present so it is visible
                const container = document.fullscreenElement || document.body;
                if (overlay.parentElement !== container) container.appendChild(overlay);
                overlay.style.position = container === document.body ? 'fixed' : 'absolute';
                overlay.style.left = '0'; overlay.style.top = '0'; overlay.style.right = '0'; overlay.style.bottom = '0';
                overlay.style.display = 'flex';
                document.body.style.overflow = 'hidden';

                // focus management
                const focusTarget = zoomBody;
                setTimeout(() => { focusTarget.focus(); }, 10);

                // trap focus
                trapFocus(overlay);

                // Keep overlay visible if fullscreen changes while open
                function _fsHandler() {
                    const newContainer = document.fullscreenElement || document.body;
                    if (overlay.parentElement !== newContainer) newContainer.appendChild(overlay);
                    overlay.style.position = newContainer === document.body ? 'fixed' : 'absolute';
                }
                document.addEventListener('fullscreenchange', _fsHandler);
                // store handler so we can remove it on close
                overlay._fsHandler = _fsHandler;
            }

            function setupZoomInteractions(wrapper, img) {
                // Zoom interaction handler
                function updateZoom(zoomFactor) {
                    currentZoomLevel = Math.max(1, Math.min(zoomFactor, 5)); // Limit zoom between 100% and 500%
                    img.style.transform = `scale(${currentZoomLevel})`;
                    img.style.transformOrigin = 'center';
                    zoomLevelDisplay.textContent = Math.round(currentZoomLevel * 100) + '%';

                    zoomOutBtn.disabled = currentZoomLevel <= 1;
                    zoomInBtn.disabled = currentZoomLevel >= 5;

                    // Update cursor and wrapper class
                    if (currentZoomLevel > 1) {
                        wrapper.classList.add('zoomed');
                    } else {
                        wrapper.classList.remove('zoomed');
                    }
                }

                // Click to zoom in/out
                img.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentZoomLevel < 5) {
                        updateZoom(currentZoomLevel + 1);
                    } else {
                        updateZoom(1);
                    }
                });

                // Scroll wheel zoom (only with Ctrl/Cmd modifier; otherwise allow natural scrolling for panning)
                wrapper.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        const zoomStep = 0.25;
                        const direction = e.deltaY > 0 ? -1 : 1;
                        updateZoom(currentZoomLevel + direction * zoomStep);
                    }
                    // Otherwise, allow natural scrolling for panning
                });

                // Panning: mouse drag to navigate zoomed image
                wrapper.addEventListener('mousedown', (e) => {
                    if (currentZoomLevel <= 1) return; // Only pan when zoomed
                    isMouseDown = true;
                    wrapper.classList.add('panning');
                    startX = e.pageX - wrapper.offsetLeft;
                    startY = e.pageY - wrapper.offsetTop;
                    scrollLeft = wrapper.scrollLeft;
                    scrollTop = wrapper.scrollTop;
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isMouseDown || currentZoomLevel <= 1) return;
                    e.preventDefault();
                    const x = e.pageX - wrapper.offsetLeft;
                    const y = e.pageY - wrapper.offsetTop;
                    const walkX = (x - startX) * 0.5;
                    const walkY = (y - startY) * 0.5;
                    wrapper.scrollLeft = scrollLeft - walkX;
                    wrapper.scrollTop = scrollTop - walkY;
                });

                document.addEventListener('mouseup', () => {
                    isMouseDown = false;
                    wrapper.classList.remove('panning');
                });

                // Keyboard shortcuts
                const keyHandler = (e) => {
                    if (overlay.style.display !== 'flex') return;
                    if (e.key === '+' || e.key === '=') { e.preventDefault(); updateZoom(currentZoomLevel + 0.25); }
                    else if (e.key === '-') { e.preventDefault(); updateZoom(currentZoomLevel - 0.25); }
                    else if (e.key.toLowerCase() === 'r') { e.preventDefault(); updateZoom(1); }
                };
                document.addEventListener('keydown', keyHandler);
                overlay._keyZoomHandler = keyHandler;
            }

            function closeZoom() {
                overlay.style.display = 'none';
                document.body.style.overflow = '';
                zoomBody.innerHTML = '';
                zoomCaption.textContent = '';
                zoomImage = null;
                currentZoomLevel = 1;
                zoomLevelDisplay.textContent = '100%';
                isMouseDown = false;
                if (lastActive && lastActive.focus) lastActive.focus();
                releaseFocusTrap();
                // clean up fullscreenchange handler if attached
                if (overlay && overlay._fsHandler) { document.removeEventListener('fullscreenchange', overlay._fsHandler); overlay._fsHandler = null; }
                if (overlay && overlay._keyZoomHandler) { document.removeEventListener('keydown', overlay._keyZoomHandler); overlay._keyZoomHandler = null; }
                // if overlay was appended to a fullscreen element and the fullscreen ended, reattach to body so subsequent opens behave predictably
                const curContainer = document.fullscreenElement || document.body;
                if (overlay.parentElement !== document.body && curContainer !== document.body) {
                    // leave as-is (still inside fullscreen element)
                } else if (overlay.parentElement !== document.body) {
                    document.body.appendChild(overlay);
                    overlay.style.position = 'fixed';
                }
            }

            // Expose an API to open the zoom overlay programmatically for other scripts
            try { window.openZoomForElement = openZoomForElement; } catch (e) { /* ignore in strict contexts */ }

            // Wire up zoom control buttons
            zoomInBtn.addEventListener('click', () => {
                if (zoomImage && currentZoomLevel < 5) {
                    const wrapper = zoomImage.closest('.zoom-image-wrapper');
                    if (wrapper) {
                        const updateZoom = (zoomFactor) => {
                            currentZoomLevel = Math.max(1, Math.min(zoomFactor, 5));
                            zoomImage.style.transform = `scale(${currentZoomLevel})`;
                            zoomImage.style.transformOrigin = 'center';
                            zoomLevelDisplay.textContent = Math.round(currentZoomLevel * 100) + '%';
                            zoomOutBtn.disabled = currentZoomLevel <= 1;
                            zoomInBtn.disabled = currentZoomLevel >= 5;
                            if (currentZoomLevel > 1) {
                                wrapper.classList.add('zoomed');
                            } else {
                                wrapper.classList.remove('zoomed');
                            }
                        };
                        updateZoom(currentZoomLevel + 0.5);
                    }
                }
            });

            zoomOutBtn.addEventListener('click', () => {
                if (zoomImage && currentZoomLevel > 1) {
                    const wrapper = zoomImage.closest('.zoom-image-wrapper');
                    if (wrapper) {
                        const updateZoom = (zoomFactor) => {
                            currentZoomLevel = Math.max(1, Math.min(zoomFactor, 5));
                            zoomImage.style.transform = `scale(${currentZoomLevel})`;
                            zoomImage.style.transformOrigin = 'center';
                            zoomLevelDisplay.textContent = Math.round(currentZoomLevel * 100) + '%';
                            zoomOutBtn.disabled = currentZoomLevel <= 1;
                            zoomInBtn.disabled = currentZoomLevel >= 5;
                            if (currentZoomLevel > 1) {
                                wrapper.classList.add('zoomed');
                            } else {
                                wrapper.classList.remove('zoomed');
                            }
                        };
                        updateZoom(currentZoomLevel - 0.5);
                    }
                }
            });

            zoomResetBtn.addEventListener('click', () => {
                if (zoomImage) {
                    const wrapper = zoomImage.closest('.zoom-image-wrapper');
                    if (wrapper) {
                        const updateZoom = (zoomFactor) => {
                            currentZoomLevel = Math.max(1, Math.min(zoomFactor, 5));
                            zoomImage.style.transform = `scale(${currentZoomLevel})`;
                            zoomImage.style.transformOrigin = 'center';
                            zoomLevelDisplay.textContent = Math.round(currentZoomLevel * 100) + '%';
                            zoomOutBtn.disabled = currentZoomLevel <= 1;
                            zoomInBtn.disabled = currentZoomLevel >= 5;
                            if (currentZoomLevel > 1) {
                                wrapper.classList.add('zoomed');
                            } else {
                                wrapper.classList.remove('zoomed');
                            }
                        };
                        updateZoom(1);
                        wrapper.scrollLeft = 0;
                        wrapper.scrollTop = 0;
                    }
                }
            });

            zoomClose.addEventListener('click', closeZoom);
            overlay.addEventListener('click', (e) => { if (e.target === overlay) closeZoom(); });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && overlay.style.display === 'flex') { e.preventDefault(); closeZoom(); } });

            // focus trap helpers
            let previousActive = null;
            function trapFocus(container) {
                previousActive = document.activeElement;
                const focusable = Array.from(container.querySelectorAll('a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])')).filter(Boolean);
                if (focusable.length) {
                    const first = focusable[0]; const last = focusable[focusable.length - 1];
                    function keyHandler(e) {
                        if (e.key === 'Tab') {
                            if (e.shiftKey && document.activeElement === first) { e.preventDefault(); last.focus(); }
                            else if (!e.shiftKey && document.activeElement === last) { e.preventDefault(); first.focus(); }
                        }
                    }
                    container.addEventListener('keydown', keyHandler);
                    container._keyHandler = keyHandler;
                }
            }
            function releaseFocusTrap() {
                const container = overlay; if (container && container._keyHandler) { container.removeEventListener('keydown', container._keyHandler); container._keyHandler = null; }
                if (previousActive && previousActive.focus) previousActive.focus(); previousActive = null;
            }

            // Attach handlers to zoomable elements
            const zoomables = Array.from(document.querySelectorAll('[data-zoomable="true"]'));
            zoomables.forEach(el => {
                console.log('[zoom] binding zoomable', el);
                // ensure focusable for keyboard activation
                if (!el.hasAttribute('tabindex')) el.setAttribute('tabindex', '0');
                // click handler: ctrl/meta key or plain click on small screens
                el.addEventListener('click', (e) => {
                    console.log('[zoom] click event', e);
                    // Ignore clicks on links or interactive controls inside the visual
                    if (e.target.closest('a,button')) return;
                    const isTouch = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
                    // Open on ctrl/meta click, touch devices, or plain click for discoverability
                    if (e.ctrlKey || e.metaKey || isTouch || (!e.ctrlKey && !e.metaKey)) {
                        e.preventDefault(); openZoomForElement(el);
                    }
                });
                el.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openZoomForElement(el); } });
            });

            // Expose API
            window.openZoomable = openZoomForElement;
        }

        // Initialize zoomable components
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initZoomableComponents); else initZoomableComponents();

        // --- Edit mode: drag & resize with persistence ---
        const LAYOUT_OV_KEY = 'presentation_layout_overrides';

        function applySavedOverrides() {
            let data = {};
            try { data = JSON.parse(localStorage.getItem(LAYOUT_OV_KEY) || '{}'); } catch (e) { data = {}; }
            Object.keys(data).forEach(id => {
                const el = document.querySelector('[data-element-id="' + id + '"]');
                if (!el) return;
                const s = data[id];
                if (s.left !== undefined) el.style.left = s.left;
                if (s.top !== undefined) el.style.top = s.top;
                if (s.width !== undefined) el.style.width = s.width;
                if (s.height !== undefined) el.style.height = s.height;
                if (s.position) el.style.position = s.position;
            });
        }

        function saveOverrides() {
            const nodes = document.querySelectorAll('[data-element-id]');
            const out = {};
            nodes.forEach(el => {
                const id = el.getAttribute('data-element-id');
                const rect = el.getBoundingClientRect();
                // only save inline styles we set (left/top/width/height/position)
                const s = {};
                if (el.style.left) s.left = el.style.left;
                if (el.style.top) s.top = el.style.top;
                if (el.style.width) s.width = el.style.width;
                if (el.style.height) s.height = el.style.height;
                if (el.style.position) s.position = el.style.position;
                if (Object.keys(s).length) out[id] = s;
            });
            localStorage.setItem(LAYOUT_OV_KEY, JSON.stringify(out));
        }

        function enableEditMode() {
            // Make a broad set of likely content blocks editable.
            // Prefer elements with explicit classes, but as a fallback mark direct children of .slide-inner.
            const preferred = ['.slide-card', '.expandable-card', '.roadmap-item', '.positioned-block', '.slide-content', '.card', '.panel'];
            preferred.forEach(sel => {
                document.querySelectorAll(sel).forEach(el => makeEditable(el));
            });

            // fallback: any direct children of .slide-inner that are not the progress container
            document.querySelectorAll('.slide-inner').forEach(inner => {
                Array.from(inner.children).forEach(child => {
                    if (child.classList.contains('progress-container')) return;
                    // avoid making core layout wrappers editable (keep these by explicit class)
                    if (child.classList.contains('slide-inner')) return;
                    // ignore very small elements like decorative dots
                    const rect = child.getBoundingClientRect();
                    if (rect.width < 30 || rect.height < 20) return;
                    makeEditable(child);
                });
            });

            // allow the user to dblclick an element to mark it editable while in edit mode
            document.addEventListener('dblclick', function dblHandler(ev) {
                if (!document.body.classList.contains('edit-mode')) return;
                const target = ev.target;
                // prefer the nearest slide-inner direct child
                const candidate = target.closest('.slide-inner > *');
                if (!candidate) return;
                // if interactive element (link/button/input), require Alt key to intentionally edit it
                if (candidate.closest('a,button,input,textarea,select') && !ev.altKey) {
                    // user must hold Alt to mark interactive widgets
                    return;
                }
                makeEditable(candidate);
                ev.preventDefault();
            });

            applySavedOverrides();
        }

        function disableEditMode() {
            document.querySelectorAll('.editable').forEach(el => {
                el.classList.remove('editable');
                const rh = el.querySelector('.resize-handle'); if (rh) rh.remove();
                el.removeEventListener('pointerdown', el._dragPointerDown);
                delete el._dragPointerDown; delete el._dragHandlers;
            });
            // save final positions
            saveOverrides();
        }

        function makeEditable(el) {
            if (!el || !el.getAttribute) return;
            // idempotent: if already editable, do nothing
            if (el.classList && el.classList.contains('editable')) return;
            // do not accidentally make the progress UI or toolbar editable
            if (el.closest && el.closest('.progress-container, .edit-toolbar, .logo-switcher, .presenter-toolbar')) return;
            // assign stable id if missing
            if (!el.getAttribute('data-element-id')) {
                el.setAttribute('data-element-id', 'el-' + Math.random().toString(36).slice(2, 9));
            }
            el.classList.add('editable');
            el.style.touchAction = 'none';
            el.style.userSelect = 'none';
            // ensure offset parent is positioned so absolute works
            const parent = el.closest('.slide-inner') || el.parentElement;
            if (parent && getComputedStyle(parent).position === 'static') parent.style.position = 'relative';
            // add resize handle
            if (!el.querySelector('.resize-handle')) {
                const rh = document.createElement('div'); rh.className = 'resize-handle'; el.appendChild(rh);
                rh.addEventListener('pointerdown', startResize.bind(null, el, rh));
            }
            // attach drag but avoid hijacking interactive child events unless user holds Alt
            const down = function (ev) {
                // if origin is interactive control, require Alt key to start drag
                if (ev.target.closest && ev.target.closest('a,button,input,textarea,select') && !ev.altKey) return;
                startDrag(el, ev);
            };
            el.addEventListener('pointerdown', down);
            el._dragPointerDown = down;
        }

        function startDrag(el, ev) {
            if (!document.body.classList.contains('edit-mode')) return;
            // ignore if starting on resize handle
            if (ev.target.classList && ev.target.classList.contains('resize-handle')) return;
            ev.preventDefault(); ev.stopPropagation(); el.setPointerCapture && el.setPointerCapture(ev.pointerId);
            const startX = ev.clientX, startY = ev.clientY;
            const rect = el.getBoundingClientRect();
            const parent = el.closest('.slide-inner') || el.parentElement;
            const pRect = parent.getBoundingClientRect();
            // make absolute if not already
            if (getComputedStyle(el).position !== 'absolute') {
                el.style.position = 'absolute';
                el.style.left = (rect.left - pRect.left) + 'px';
                el.style.top = (rect.top - pRect.top) + 'px';
                el.style.width = rect.width + 'px';
                el.style.height = rect.height + 'px';
            }
            function move(e) {
                const dx = e.clientX - startX, dy = e.clientY - startY;
                el.style.left = (rect.left - pRect.left + dx) + 'px';
                el.style.top = (rect.top - pRect.top + dy) + 'px';
            }
            function up(e) {
                document.removeEventListener('pointermove', move);
                document.removeEventListener('pointerup', up);
                try { el.releasePointerCapture && el.releasePointerCapture(ev.pointerId); } catch (e) { }
                saveOverrides();
            }
            document.addEventListener('pointermove', move);
            document.addEventListener('pointerup', up);
        }

        function startResize(el, handle, ev) {
            if (!document.body.classList.contains('edit-mode')) return;
            ev.preventDefault(); ev.stopPropagation(); handle.setPointerCapture && handle.setPointerCapture(ev.pointerId);
            const startX = ev.clientX, startY = ev.clientY;
            const rect = el.getBoundingClientRect();
            const parent = el.closest('.slide-inner') || el.parentElement;
            const pRect = parent.getBoundingClientRect();
            function mover(e) {
                const w = Math.max(40, rect.width + (e.clientX - startX));
                const h = Math.max(24, rect.height + (e.clientY - startY));
                el.style.width = w + 'px';
                el.style.height = h + 'px';
            }
            function ender(e) {
                document.removeEventListener('pointermove', mover);
                document.removeEventListener('pointerup', ender);
                try { handle.releasePointerCapture && handle.releasePointerCapture(ev.pointerId); } catch (e) { }
                saveOverrides();
            }
            document.addEventListener('pointermove', mover);
            document.addEventListener('pointerup', ender);
        }

        // Selection and pixel-nudge support (use +/- keys)
        let _selectedEditable = null;
        const _coords = document.createElement('div');
        _coords.className = 'edit-coords';
        document.body.appendChild(_coords);

        function updateCoordsDisplay() {
            if (!_selectedEditable) { _coords.style.display = 'none'; return; }
            const el = _selectedEditable;
            const parent = el.closest('.slide-inner') || el.parentElement;
            const pRect = parent.getBoundingClientRect();
            const rect = el.getBoundingClientRect();
            const left = Math.round(rect.left - pRect.left);
            const top = Math.round(rect.top - pRect.top);
            const w = Math.round(rect.width);
            const h = Math.round(rect.height);
            _coords.style.display = 'block';
            _coords.textContent = `x:${left}px y:${top}px ${w}×${h}`;
        }

        function selectEditable(el) {
            if (!document.body.classList.contains('edit-mode')) return;
            if (_selectedEditable === el) return;
            if (_selectedEditable) _selectedEditable.classList.remove('selected');
            _selectedEditable = el;
            if (el) el.classList.add('selected');
            updateCoordsDisplay();
        }

        function deselectEditable() {
            if (_selectedEditable) _selectedEditable.classList.remove('selected');
            _selectedEditable = null;
            updateCoordsDisplay();
        }

        // clicking an editable element selects it (only in edit mode)
        document.addEventListener('click', function (ev) {
            if (!document.body.classList.contains('edit-mode')) return;
            const el = ev.target.closest && ev.target.closest('.editable');
            if (el) {
                selectEditable(el);
                ev.stopPropagation();
            } else {
                deselectEditable();
            }
        });

        // keyboard nudging: use +/- keys to move selected element horizontally (1px; Ctrl/meta=5; Shift=10)
        document.addEventListener('keydown', function (ev) {
            if (!document.body.classList.contains('edit-mode')) return;
            if (!_selectedEditable) return;
            const tgt = ev.target;
            if (tgt && (tgt.tagName === 'INPUT' || tgt.tagName === 'TEXTAREA' || tgt.isContentEditable)) return;
            const key = ev.key;
            const plusKeys = ['+', '=', 'Add'];
            const minusKeys = ['-', '_', 'Subtract'];
            if (!plusKeys.includes(key) && !minusKeys.includes(key)) return;
            ev.preventDefault(); ev.stopPropagation();
            const step = ev.shiftKey ? 10 : (ev.ctrlKey || ev.metaKey ? 5 : 1);
            const el = _selectedEditable;
            const parent = el.closest('.slide-inner') || el.parentElement;
            const pRect = parent.getBoundingClientRect();
            const rect = el.getBoundingClientRect();
            if (getComputedStyle(el).position !== 'absolute') {
                el.style.position = 'absolute';
                el.style.left = (rect.left - pRect.left) + 'px';
                el.style.top = (rect.top - pRect.top) + 'px';
                el.style.width = rect.width + 'px';
                el.style.height = rect.height + 'px';
            }
            let left = parseFloat(el.style.left || (rect.left - pRect.left));
            if (plusKeys.includes(key)) left += step; else left -= step;
            el.style.left = Math.round(left) + 'px';
            updateCoordsDisplay();
            saveOverrides();
        });

        function applySavedOverridesOnLoad() { applySavedOverrides(); }

        // apply any saved overrides now (so slides opened in edit mode persist)
        applySavedOverridesOnLoad();

        // --- Tab button initialization ---
        function initializeTabs() {
            // Find all tabs and add click handlers
            document.querySelectorAll('[role="tab"]').forEach(tab => {
                tab.addEventListener('click', handleTabClick);
                tab.addEventListener('keydown', handleTabKeydown);
            });

            // Ensure the FIRST tab is active by default on every tablist unless explicitly opted out
            document.querySelectorAll('[role="tablist"]').forEach(tablist => {
                if (tablist.getAttribute('data-no-auto-init') === 'true') return;
                const tabs = Array.from(tablist.querySelectorAll('[role="tab"]'));
                if (!tabs.length) return;
                const first = tabs[0];

                // Deactivate all tabs in this tablist
                tabs.forEach(t => {
                    t.setAttribute('aria-selected', 'false');
                    t.classList.remove('active');
                });

                // Hide all panels within the containing slide
                const slide = tablist.closest('.slide-container');
                if (slide) {
                    const tabPanels = slide.querySelectorAll('[role="tabpanel"]');
                    tabPanels.forEach(p => {
                        p.setAttribute('aria-hidden', 'true');
                        p.hidden = true;
                    });
                }

                // Activate the first tab and show its panel
                first.setAttribute('aria-selected', 'true');
                first.classList.add('active');
                const panelId = first.getAttribute('aria-controls');
                if (panelId) {
                    const panel = document.getElementById(panelId) || (slide && slide.querySelector('#' + panelId.replace(/^#/, '')));
                    if (panel) {
                        panel.setAttribute('aria-hidden', 'false');
                        panel.hidden = false;
                    }
                }
            });
        }

        function handleTabClick(event) {
            const tab = event.currentTarget;
            const tablist = tab.closest('[role="tablist"]');
            if (!tablist) return;

            // Get the panel to show
            const panelId = tab.getAttribute('aria-controls');
            if (!panelId) return;

            const panel = document.getElementById(panelId);
            if (!panel) return;

            // Get the slide that contains this tablist
            const slide = tablist.closest('.slide-container');
            if (!slide) return;

            // Deactivate all tabs in this tablist
            tablist.querySelectorAll('[role="tab"]').forEach(t => {
                t.setAttribute('aria-selected', 'false');
                t.classList.remove('active');
            });

            // Hide all panels in this tablist's parent
            const tabPanels = slide.querySelectorAll('[role="tabpanel"]');
            tabPanels.forEach(p => {
                p.setAttribute('aria-hidden', 'true');
                p.hidden = true;
            });

            // Activate the clicked tab
            tab.setAttribute('aria-selected', 'true');
            tab.classList.add('active');

            // Show the corresponding panel
            panel.setAttribute('aria-hidden', 'false');
            panel.hidden = false;
        }

        function handleTabKeydown(event) {
            const tab = event.currentTarget;
            const tablist = tab.closest('[role="tablist"]');
            if (!tablist) return;

            const tabs = Array.from(tablist.querySelectorAll('[role="tab"]'));
            const currentIndex = tabs.indexOf(tab);
            let targetTab = null;

            if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
                event.preventDefault();
                targetTab = tabs[currentIndex - 1] || tabs[tabs.length - 1];
            } else if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
                event.preventDefault();
                targetTab = tabs[currentIndex + 1] || tabs[0];
            } else if (event.key === 'Home') {
                event.preventDefault();
                targetTab = tabs[0];
            } else if (event.key === 'End') {
                event.preventDefault();
                targetTab = tabs[tabs.length - 1];
            }

            if (targetTab) {
                targetTab.focus();
                targetTab.click();
            }
        }

        // Initialize tabs when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeTabs);
        } else {
            initializeTabs();
        }

        initNavigation();

        // ========== Image Rectangle Highlight Feature ==========
        // Allows users to highlight rectangular areas on images by dragging
        // Similar to Plotly's selection tool
        // Works with zoom feature - Shift+Click to highlight instead of zoom
        // Only one rectangle at a time - drawing a new one removes the previous
        // Keyboard shortcuts: Delete/Backspace or C to remove highlight

        function initImageHighlighter() {
            // Inject CSS for highlight rectangles
            const highlightCSS = `
            .image-highlight-container {
                position: relative;
                display: inline-block;
            }
            
            .image-highlight-container img {
                display: block;
                user-select: none;
            }
            
            .image-highlight-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10;
            }
            
            .highlight-rectangle {
                position: absolute;
                border: 2px solid #FF4444;
                background: rgba(255, 68, 68, 0.12);
                pointer-events: all;
                cursor: move;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
                transition: box-shadow 0.2s ease, border-color 0.2s ease;
            }
            
            .highlight-rectangle:hover {
                box-shadow: 0 3px 10px rgba(255, 68, 68, 0.3);
                border-color: #CC0000;
            }
            
            .highlight-rectangle.selected {
                border-color: #0066CC;
                border-width: 3px;
                background: rgba(0, 102, 204, 0.15);
                box-shadow: 0 4px 12px rgba(0, 102, 204, 0.4);
            }
            
            .highlight-rectangle.active {
                border-color: #0066CC;
                background: rgba(0, 102, 204, 0.15);
                box-shadow: 0 4px 12px rgba(0, 102, 204, 0.4);
            }
            
            .highlight-hint {
                position: absolute;
                top: 8px;
                left: 8px;
                background: rgba(0, 0, 0, 0.75);
                color: white;
                padding: 6px 10px;
                border-radius: 4px;
                font-size: 10px;
                pointer-events: none;
                z-index: 12;
                opacity: 0;
                transition: opacity 0.3s ease;
                line-height: 1.4;
            }
            
            .image-highlight-container:hover .highlight-hint {
                opacity: 1;
            }
            
            @media (prefers-reduced-motion: reduce) {
                .highlight-rectangle,
                .highlight-hint {
                    transition: none !important;
                }
            }
            `;

            const styleEl = document.createElement('style');
            styleEl.textContent = highlightCSS;
            document.head.appendChild(styleEl);

            // State for each image
            const imageStates = new WeakMap();

            // Initialize highlighter for all figures with images
            function setupImageHighlighters() {
                const figures = document.querySelectorAll('figure.method-visual[data-zoomable="true"]');

                figures.forEach(fig => {
                    // Skip if already enhanced
                    if (fig.classList.contains('image-highlight-enabled')) return;
                    fig.classList.add('image-highlight-enabled');

                    // Only enable if figure contains an <img>
                    const img = fig.querySelector('img');
                    if (!img) return;
                    if (img.closest('.nav-arrow, .ucl-logo, .logo-svg, button')) return;
                    if (img.getAttribute('data-no-highlight') === 'true') return;

                    // Check if image is reasonably sized for highlighting
                    const rect = img.getBoundingClientRect();
                    if (rect.width < 100 || rect.height < 100) return;

                    enableFigureHighlighting(fig, img);
                });
            }

            function enableFigureHighlighting(fig, img) {
                // Create overlay for highlights
                const overlay = document.createElement('div');
                overlay.className = 'image-highlight-overlay';
                overlay.style.pointerEvents = 'none';
                overlay.style.position = 'absolute';
                overlay.style.top = 0;
                overlay.style.left = 0;
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.zIndex = 10;
                fig.style.position = 'relative';
                fig.appendChild(overlay);

                // Create hint with keyboard shortcuts
                const hint = document.createElement('div');
                hint.className = 'highlight-hint';
                hint.innerHTML = 'Shift+Drag to highlight<br>Del or C: remove highlight';
                fig.appendChild(hint);

                // Initialize state
                const state = {
                    isDrawing: false,
                    startX: 0,
                    startY: 0,
                    currentRect: null,
                    rectangles: [],
                    selectedRect: null
                };
                imageStates.set(fig, state);

                // Event handlers - only draw when Shift is held
                fig.addEventListener('mousedown', (e) => {
                    // Only start drawing if Shift key is held (to avoid interfering with zoom)
                    if (e.shiftKey) {
                        handleMouseDown(e, fig, overlay, state);
                    }
                });
                fig.addEventListener('mousemove', (e) => handleMouseMove(e, fig, overlay, state));
                fig.addEventListener('mouseup', (e) => handleMouseUp(e, fig, overlay, state));
                fig.addEventListener('mouseleave', (e) => handleMouseUp(e, fig, overlay, state));

                // Update cursor based on Shift key
                function updateCursor(e) {
                    if (e.shiftKey && !e.target.closest('.highlight-rectangle')) {
                        fig.style.cursor = 'crosshair';
                    } else {
                        fig.style.cursor = '';
                    }
                }

                fig.addEventListener('keydown', updateCursor);
                fig.addEventListener('keyup', updateCursor);
                fig.addEventListener('mousemove', updateCursor);

                // Global keyboard shortcuts for this figure
                document.addEventListener('keydown', (e) => handleKeyboard(e, fig, overlay, state));
            }

            function handleMouseDown(e, wrapper, overlay, state) {
                // Only handle left mouse button and Shift key must be held
                if (e.button !== 0 || !e.shiftKey) return;

                // Don't start drawing if clicking on existing rectangle
                if (e.target.closest('.highlight-rectangle')) return;

                // Clear all existing rectangles before drawing a new one (only one at a time)
                clearAllHighlights(overlay, state);

                const rect = wrapper.getBoundingClientRect();
                state.isDrawing = true;
                state.startX = e.clientX - rect.left;
                state.startY = e.clientY - rect.top;

                // Create new rectangle
                const highlightRect = document.createElement('div');
                highlightRect.className = 'highlight-rectangle';
                highlightRect.style.left = state.startX + 'px';
                highlightRect.style.top = state.startY + 'px';
                highlightRect.style.width = '0px';
                highlightRect.style.height = '0px';

                state.currentRect = highlightRect;
                overlay.appendChild(highlightRect);

                e.preventDefault();
                e.stopPropagation(); // Prevent zoom from triggering
            }

            function handleMouseMove(e, wrapper, overlay, state) {
                if (!state.isDrawing || !state.currentRect) return;

                const rect = wrapper.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;

                // Calculate rectangle dimensions
                const width = Math.abs(currentX - state.startX);
                const height = Math.abs(currentY - state.startY);
                const left = Math.min(state.startX, currentX);
                const top = Math.min(state.startY, currentY);

                // Constrain to image bounds
                const maxWidth = rect.width - left;
                const maxHeight = rect.height - top;

                state.currentRect.style.left = Math.max(0, left) + 'px';
                state.currentRect.style.top = Math.max(0, top) + 'px';
                state.currentRect.style.width = Math.min(width, maxWidth) + 'px';
                state.currentRect.style.height = Math.min(height, maxHeight) + 'px';
            }

            function handleMouseUp(e, wrapper, overlay, state) {
                if (!state.isDrawing) return;

                state.isDrawing = false;

                if (state.currentRect) {
                    const width = parseFloat(state.currentRect.style.width);
                    const height = parseFloat(state.currentRect.style.height);

                    // Only keep rectangle if it's large enough (minimum 15x15 pixels)
                    if (width < 15 || height < 15) {
                        state.currentRect.remove();
                    } else {
                        state.rectangles.push(state.currentRect);

                        // Make rectangle selectable and draggable
                        makeRectangleInteractive(state.currentRect, wrapper, state);
                    }

                    state.currentRect = null;
                }
            }

            function makeRectangleInteractive(rect, wrapper, state) {
                let isDragging = false;
                let startX, startY, initialLeft, initialTop;

                // Click to select
                rect.addEventListener('click', (e) => {
                    e.stopPropagation();

                    // Deselect all other rectangles
                    state.rectangles.forEach(r => r.classList.remove('selected'));

                    // Select this one
                    rect.classList.add('selected');
                    state.selectedRect = rect;
                });

                // Drag to move
                rect.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    // Select on drag start
                    state.rectangles.forEach(r => r.classList.remove('selected'));
                    rect.classList.add('selected', 'active');
                    state.selectedRect = rect;

                    isDragging = true;

                    const wrapperRect = wrapper.getBoundingClientRect();
                    startX = e.clientX;
                    startY = e.clientY;
                    initialLeft = parseFloat(rect.style.left);
                    initialTop = parseFloat(rect.style.top);

                    const moveHandler = (e) => {
                        if (!isDragging) return;

                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;

                        let newLeft = initialLeft + deltaX;
                        let newTop = initialTop + deltaY;

                        // Constrain to wrapper bounds
                        const rectWidth = parseFloat(rect.style.width);
                        const rectHeight = parseFloat(rect.style.height);
                        const maxLeft = wrapperRect.width - rectWidth;
                        const maxTop = wrapperRect.height - rectHeight;

                        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                        newTop = Math.max(0, Math.min(newTop, maxTop));

                        rect.style.left = newLeft + 'px';
                        rect.style.top = newTop + 'px';
                    };

                    const upHandler = () => {
                        isDragging = false;
                        rect.classList.remove('active');
                        document.removeEventListener('mousemove', moveHandler);
                        document.removeEventListener('mouseup', upHandler);
                    };

                    document.addEventListener('mousemove', moveHandler);
                    document.addEventListener('mouseup', upHandler);
                });
            }

            function handleKeyboard(e, wrapper, overlay, state) {
                // Only handle if an image highlight container is focused or contains focused element
                const isFocused = wrapper.contains(document.activeElement) ||
                    document.activeElement === document.body;

                if (!isFocused && !wrapper.querySelector('.highlight-rectangle.selected')) return;

                // Delete or Backspace: remove selected rectangle
                if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedRect) {
                    e.preventDefault();
                    const index = state.rectangles.indexOf(state.selectedRect);
                    if (index > -1) {
                        state.rectangles.splice(index, 1);
                    }
                    state.selectedRect.remove();
                    state.selectedRect = null;
                }
                // 'C' key: clear all highlights
                else if (e.key.toLowerCase() === 'c' && (e.ctrlKey || e.metaKey || (!e.ctrlKey && !e.metaKey && state.rectangles.length > 0))) {
                    // Allow Ctrl+C for copy, but standalone 'C' clears highlights
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        clearAllHighlights(overlay, state);
                    }
                }
            }

            function clearAllHighlights(overlay, state) {
                state.rectangles.forEach(rect => rect.remove());
                state.rectangles = [];
                state.selectedRect = null;
                if (state.currentRect) {
                    state.currentRect.remove();
                    state.currentRect = null;
                }
            }

            // Initialize on DOM ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupImageHighlighters);
            } else {
                setupImageHighlighters();
            }

            // Re-run after slide changes to catch dynamically loaded images
            document.addEventListener('slidechange', () => {
                setTimeout(setupImageHighlighters, 100);
            });
        }

        // Initialize the image highlighter feature
        initImageHighlighter();
    </script>
</body>

</html>